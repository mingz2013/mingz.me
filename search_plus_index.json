{"./":{"url":"./","title":"Introduction","keywords":"","body":"之前的 blog项目实在不好用，以后的笔记都转移到这里来 流程图插件 https://github.com/knsv/mermaid "},"algorithm/":{"url":"algorithm/","title":"algorithm","keywords":"","body":""},"compiler/":{"url":"compiler/","title":"compiler","keywords":"","body":""},"compiler/compiler.html":{"url":"compiler/compiler.html","title":"编程语言泛讲","keywords":"","body":"1. 编程语言的分类1.1. 解释型与编译型之分1.1.1. 解释型1.1.2. 编译型1.2. 动态类型与静态类型之分1.2.1. 动态1.2.2. 静态1.3. 强类型与弱类型之分1.3.1. 强类型1.3.2. 弱类型2. 编译器前端与编译器后端2.1. 编译器前端(Front End)2.2. 编译器后端(Back End)3. 编程语言的开发方法3.1. 工具生成3.2. 手工构造4. 编程语言的开发过程4.1. 编程语言的设计4.1.1. bnf, ebnf定义文法4.1.2. 地铁图描述文法4.1.3. 少许理论知识4.2. 词法分析4.3. 语法分析4.4. 抽象语法树4.5. 语义分析4.6. 符号管理4.7. 生成中间代码4.8. 生成汇编代码4.9. 二进制格式4.10. 二进制生成，汇编器4.11. 可执行文件生成，链接器4.12. 错误处理4.13. 优化5. CPU架构6. 虚拟机的设计6.1. 字节码文件的解析6.2. 运行时数据区6.2.1. 栈(stack)的设计6.2.2. 堆(heap)的设计6.2.3. 局部变量6.2.4. 全局变量6.3. 汇编指令与机器码的设计6.4. 解释器的设计6.5. GC垃圾回收7. JIT8. 编程语言分类漫谈9. 编程语言开发示例demo10. 参考资料10.1. 书籍禁止转载 一些图文 出自参考书籍中的截图，如有侵权，请联系删除 1. 编程语言的分类 1.1. 解释型与编译型之分 编程语言可分为解释型和编译型。 1.1.1. 解释型 源代码转换为某种中间状态，如语法树，语法树直接执行 源代码，词法分析，生成token串，语法分析，生成分析树，语法分析树，或语法树，抽象语法树，执行 纯粹的解释型，读一句，解释执行一句，执行到有语法错误的时候才会报错 字节码，解释器运行字节码, 也可称为虚拟机 将抽象语法树转换成字节码，字节码可在虚拟机里执行 也有编译的一个过程 1.1.2. 编译型 编译过程 词法分析, 生成token串，语法分析，生成抽象语法树，生成中间代码，生成各个CPU架构的汇编代码，生成各个平台的二进制， 二进制：真实CPU架构下的二进制，或虚拟机下的二进制（操作码或字节码） 链接过程 链接器，链接成可执行文件 1.2. 动态类型与静态类型之分 1.2.1. 动态 1.2.2. 静态 1.3. 强类型与弱类型之分 1.3.1. 强类型 1.3.2. 弱类型 2. 编译器前端与编译器后端 2.1. 编译器前端(Front End) 从源代码到抽象语法树的过程 2.2. 编译器后端(Back End) 从抽象语法树到二进制的过程 3. 编程语言的开发方法 工具型 手工型 3.1. 工具生成 用一些工具，定义一些文法，通过工具输入文法，自动生成编译器代码。 或者 用正则表达式解析源代码 yacc,lex Javacc 3.2. 手工构造 自顶向下的分析，编写代码 4. 编程语言的开发过程 首先进行编程语言的设计，然后是词法分析，语法分析，语义分析，生成抽象语法树，生成中间代码，生成操作码， 4.1. 编程语言的设计 编程语言的设计，有两种文法表示 4.1.1. bnf, ebnf定义文法 BNF（巴科斯范式，Backus Normal Form） EBNF(扩展巴克斯范式，Extend BNF) 示例： 4.1.2. 地铁图描述文法 4.1.3. 少许理论知识 消除左递归（LL（1）） LL(1) LALR(1) 理解 i++ + ++i 怎么执行的 TODO 4.2. 词法分析 将源代码分割成若干个记号（token）的过程。 首先定义token(记号)，用ebnf文法定义词法 每个token有相应的有限自动机 顺序读取源代码文件每个字符，用token的有限自动机来选择生成不同的token 4.3. 语法分析 即从记号构建分析树（parse tree）的过程。分析树也叫作语法树（syntax tree）或抽象语法树（abstract syntax tree，AST）。 用ebnf定义文法，根据文法写不同的解析代码 4.4. 抽象语法树 终结符与非终结符 可直接编写eval方法，执行每个节点 4.5. 语义分析 检查AST中，是否有语义错误，比如不能除0等 4.6. 符号管理 需要将各个级别的变量，保存到环境变量中，并标记好级别， 在eval的时候，如果生成变量，就new Var，并记录到环境变量中， 如果计算用到了变量，就从环境变量中取出Var用于计算 如果推出当前级别的空间，就释放当前级别的空间内的变量,作用域管理 4.7. 生成中间代码 符号表，语义分析，中间代码优化等。 4.8. 生成汇编代码 了解不同CPU架构的汇编语言，或自定义虚拟机的汇编语法 汇编代码优化 4.9. 二进制格式 4.10. 二进制生成，汇编器 了解各个平台的可执行文件结构，格式，编写汇编器，生成二进制 4.11. 可执行文件生成，链接器 链接成可执行文件 4.12. 错误处理 伴随着每个过程，都需要有错误处理，和友好的错误提示 4.13. 优化 中间代码优化，汇编代码优化，等，每一部分都有优化部分 5. CPU架构 intel x86 ARM Power TODO 6. 虚拟机的设计 模拟真实CPU架构 定义栈空间，定义堆空间，定义寄存器，等数据结构 6.1. 字节码文件的解析 读取文件，读取一个个指令，巨大的switch case结构 6.2. 运行时数据区 6.2.1. 栈(stack)的设计 栈帧 6.2.2. 堆(heap)的设计 6.2.3. 局部变量 6.2.4. 全局变量 6.3. 汇编指令与机器码的设计 6.4. 解释器的设计 6.5. GC垃圾回收 7. JIT java，.NET Framework都具备在运行的同时将字节码转换为机器码的功能，这叫做JIT，Just-In-Time编译技术。 8. 编程语言分类漫谈 JVM虚拟机，Java，Groovy，Scala，Clojure，Jython，JRuby等。 CPython Pypy go js 9. 编程语言开发示例demo py.calc解释型语言 10. 参考资料 10.1. 书籍 《Lua设计与实现》 《Lua 源码欣赏》 《Go 1.5 源码剖析》 《Python源码剖析--深度探索动态语言核心技术》 《编译器构造（Java语言版）》 《自己动手写Java虚拟机》 《揭秘Java虚拟机-JVM设计原理与实现》 《自制编程语言》 《两周自制脚本语言》 《自制编译器》 《自己动手构造编译系统 编译、汇编与链接》 《自己动手写编译器、链接器》 《C编译器剖析》 《可变目标C编译器：设计与实现》 《深入分析GCC》 《高级编译器设计与实现》 《编译系统透视 图解编译原理》 《编译原理》 《现代编译原理：c语言描述》 《程序是怎样跑起来的》 《计算的本质：深入剖析程序和计算机》 "},"compiler/ollvm.html":{"url":"compiler/ollvm.html","title":"ollvm","keywords":"","body":"1. 做的事情2. 名词介绍2.1. gcc2.2. llvm2.3. clang2.4. ollvm3. llvm相关架构与原理4. ollvm扩展内容5. demo6. 攻与防7. github8. 参考书籍9. links1. 做的事情 之前已经做的东西，资源加密，符号混淆 本次做的事情，代码膨胀，变形 2. 名词介绍 2.1. gcc GNU编译器套件（GNU Compiler Collection）包括C、C++、Objective-C、Fortran、Java、Ada和Go语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）。GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由。 2.2. llvm LLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。 2.3. clang Clang是一个C语言、C++、Objective-C语言的轻量级编译器。源代码发布于BSD协议下。Clang将支持其普通lambda表达式、返回类型的简化处理以及更好的处理constexpr关键字。 2.4. ollvm OLLVM（Obfuscator-LLVM）是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个项目，这个项目的目标是提供一个LLVM编译套件的开源分支，能够通过代码混淆和防篡改，增加对逆向工程的难度，提供更高的软件安全性。目前，OLLVM已经支持LLVM-4.0.1版本。OLLVM的混淆操作就是在中间表示IR层，通过编写Pass来混淆IR，然后后端依据IR来生成的目标代码也就被混淆了。得益于LLVM的设计，OLLVM适用LLVM支持的所有语言（C, C++, Objective-C, Ada 和 Fortran）和目标平台（x86, x86-64, PowerPC, PowerPC-64, ARM, Thumb, SPARC, Alpha, CellSPU,MIPS, MSP430, SystemZ, 和 XCore） 3. llvm相关架构与原理 https://llvm.org/docs/ http://www.aosabook.org/en/llvm.html https://llvm.org/docs/WritingAnLLVMPass.html 4. ollvm扩展内容 https://github.com/obfuscator-llvm/obfuscator/wiki -fla 控制流扁平化的PASS参数 -sub指令替换的PASS参数 -bcf虚假控制流的PASS参数 https://blog.csdn.net/chrisnotfound/article/details/79026449 5. demo 用Armariris演示编译一个简单的C源码，试用各种参数。 对编译出的二进制进行分析，查看文件大小，用ida分析二进制，展示流图。 6. 攻与防 https://bbs.pediy.com/thread-217727.htm http://www.freebuf.com/articles/terminal/130142.html 7. github llvm ollvm Hikari Armariris mcsema 8. 参考书籍 《iOS应用逆向与安全》 《编译与反编译技术实战》 《LLVM Cookbook中文版》 9. links gcc clang LLVM和GCC的区别 "},"lang/":{"url":"lang/","title":"lang","keywords":"","body":""},"lang/golang/":{"url":"lang/golang/","title":"golang","keywords":"","body":""},"lang/html/":{"url":"lang/html/","title":"html","keywords":"","body":""},"lang/js/":{"url":"lang/js/","title":"js","keywords":"","body":""},"lang/python/":{"url":"lang/python/","title":"python","keywords":"","body":""},"linux/":{"url":"linux/","title":"linux","keywords":"","body":""},"linux/centos7_utf8.html":{"url":"linux/centos7_utf8.html","title":"Centos7 UTF8编码配置","keywords":"","body":"1.1. 查看系统版本信息1.2. 当前文件配置1.3. 查看locale环境变量1.4. 修改1.5. 重新登录1.6. 查看locale环境变量1.7. 查看当前安装的语言包1.1. 查看系统版本信息 $cat /etc/redhat-release CentOS Linux release 7.1.1503 (Core) $uname -m x86_64 $uname -r 3.10.0-229.el7.x86_64 $uname -a Linux VM_7_30_centos 3.10.0-229.el7.x86_64 #1 SMP Fri Mar 6 11:36:42 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux 1.2. 当前文件配置 $cat /etc/locale.conf LANG=\"C\" 1.3. 查看locale环境变量 $locale LANG=C LC_CTYPE=\"C\" LC_NUMERIC=\"C\" LC_TIME=\"C\" LC_COLLATE=\"C\" LC_MONETARY=\"C\" LC_MESSAGES=\"C\" LC_PAPER=\"C\" LC_NAME=\"C\" LC_ADDRESS=\"C\" LC_TELEPHONE=\"C\" LC_MEASUREMENT=\"C\" LC_IDENTIFICATION=\"C\" LC_ALL= 1.4. 修改 $vim /etc/locale.conf #LANG=\"C\" LANG=\"en_US.UTF-8\" 1.5. 重新登录 $exit $login 1.6. 查看locale环境变量 $locale LANG=en_US.UTF-8 LC_CTYPE=\"en_US.UTF-8\" LC_NUMERIC=\"en_US.UTF-8\" LC_TIME=\"en_US.UTF-8\" LC_COLLATE=\"en_US.UTF-8\" LC_MONETARY=\"en_US.UTF-8\" LC_MESSAGES=\"en_US.UTF-8\" LC_PAPER=\"en_US.UTF-8\" LC_NAME=\"en_US.UTF-8\" LC_ADDRESS=\"en_US.UTF-8\" LC_TELEPHONE=\"en_US.UTF-8\" LC_MEASUREMENT=\"en_US.UTF-8\" LC_IDENTIFICATION=\"en_US.UTF-8\" LC_ALL= 1.7. 查看当前安装的语言包 $locale -a | grep en_US en_US en_US.iso88591 en_US.iso885915 en_US.utf8 "},"micros/":{"url":"micros/","title":"micros","keywords":"","body":"1. MicroService架构探索禁止转载 本目录内文章，图片和文字资源大多来自于网络和参考书籍，如有侵权，请联系删除 1. MicroService架构探索 各位领导大家好，今天给大家汇报一下最近的一些关于微服务的研究。 MicroService Consul go-micro SpringCloud Docker Docker Compose Docker Swarm Mesos Kubernetes DevOps OpenShift 3 Serverless Istio OpenShift 4 Chaos Engineering 总结 Q & A "},"micros/microservice.html":{"url":"micros/microservice.html","title":"MicroService","keywords":"","body":"1. MicroService1.1. 概述1.1.1. 微服务设计的理念：1.1.2. 为什么要使用微服务1.1.3. 微服务特点，如下所述。1.1.4. 微服务带来的问题。1.2. todos demo1.3. 参考资料1. MicroService 1.1. 概述 微服务是一种软件架构模式，用来把大而重的应用程序切成许多可管理的、可管理的独立服务，各服务之间的通信并不受不同语言的协议影响，每个服务只管做好一件事情。 1.1.1. 微服务设计的理念： 各服务要小 - 单一的业务目标应该是要细粒度，就像Unix的”只做一件事并且要做好”理念。 组织文化要包含部署与测试的自动化，这个降低管理与操作的负担。 设计原则要包含失败与错误，就像抗脆弱的系统。 1.1.2. 为什么要使用微服务 随着组织的扩大，使用的技术和员工的数量都在增加，管理单一代码实现的服务，只会变得越来越复杂。 1.1.3. 微服务特点，如下所述。 在结构上，将原有的从技术角度拆分的组件，升级为从业务角度拆分的独立运行的服务，这些服务具备各自的实现平台，并且独占自有数据，在服务之间以智能端点和哑管道的方式通信。 在工程上，从产品而非项目的角度进行设计，强调迭代，自动化和面向故障的设计方法。 1.1.4. 微服务带来的问题。 微服务架构在很大程度上提高了应用的伸缩性，方便了部门或业务之间的协作，使技术岗位能够更好地引入新技术并提高自动化程度，最终达到减耗增效的目的，然而和所有新方法一样，微服务架构在解决老问题的同时，也带来了一些新问题，例如： 实例数量急剧增长，对部署和运维的自动化要求更高。 用网络调动代替内部API，对网络这一不可靠的基础设施依赖增强 调用链路变长，分布式跟踪称为必选项目 日志分散严重，跟踪和分析难度加大 服务分散，受攻击面积更大 在不同的服务之间存在协作关系，需要有更好的跨服务控制协调能力 自动伸缩，路由管理，故障控制，存储共享，等等。 1.2. todos demo TODO 1.3. 参考资料 "},"micros/consul.html":{"url":"micros/consul.html","title":"Consul","keywords":"","body":"1. Consul1.1. 概念1.1.1. 服务注册与发现1.1.2. Consul1.2. 演示1.2.1. install consul1.2.2. run the agent1.2.3. services1.2.4. Connect1.2.5. Consul Cluster1.2.6. Health Checks1.2.7. KV Data1.2.8. Web UI1.3. todos demo1.4. 参考资料1.4.1. GitHub1.4.2. Website1. Consul 1.1. 概念 1.1.1. 服务注册与发现 1.1.2. Consul 1.2. 演示 1.2.1. install consul $brew install consul verifying the installation $consul 1.2.2. run the agent starting the agent $consul agent -dev 为了简单，我们以开发模式启动consul agent。这个模式可以快速和容易的启动一个单节点的consul环境. 这个模式不适合用于生产环境，因为它不保存任何状态。 cluster members $consul members Node Address Status Type Build Protocol DC Segment avril.local 127.0.0.1:8301 alive server 1.3.0 2 dc1 在另一个terminal中执行consul members，你可以看到consul cluster的members，你可以看到，只有 one member（yourself）. 输出显示了我们自己的node，这address it is running on，its health state, its role in the cluster, and some version information. 额外的元数据信息可以通过-detailed flag看到. 这个命令的输出，基于gossip protocol, and is 最终一致的。也就是说，在任何节点在同一时间，看到的世界，by 你本地的agent 可能不完全匹配这状态在servers。一个强一致的系统的展示，可以用这HTTP API 去远程请求consul servers $curl localhost:8500/v1/catalog/nodes [ { \"ID\": \"9a8b671d-ffdb-6445-f436-9ad02cf7d219\", \"Node\": \"avril.local\", \"Address\": \"127.0.0.1\", \"Datacenter\": \"dc1\", \"TaggedAddresses\": { \"lan\": \"127.0.0.1\", \"wan\": \"127.0.0.1\" }, \"Meta\": { \"consul-network-segment\": \"\" }, \"CreateIndex\": 9, \"ModifyIndex\": 10 } ] 对于这个HTTP API额外的说一下，DNS interface可以被用来请求这个节点。提示：你必须确保你的DNS 发现 指向 consul agent's DNS server, which 运行在 8600默认端口上的。这DNS 入口的格式，（类似 \"avril.local.node.consul\"）可以被发现在一会 $dig @127.0.0.1 -p 8600 avril.local.node.cansul ; > DiG 9.10.6 > @127.0.0.1 -p 8600 avril.local.node.cansul ; (1 server found) ;; global options: +cmd ;; Got answer: ;; ->>HEADERstopping the agent 你可以ctrl-C去优雅的停止这个agent，当中断这个agent，你可以看到，它离开的cluster，and shut down。 为了优雅的leaving，consul 通知其他集群成员，这个节点离开了。如果你强行kill这个agent 进程，其他成员将发现这个node fail的。 当一个成员离开，它的服务和检查，将从catalog移除。当一个成员fails，它的健康仅仅标记为critical, 但它不会从catalog中移除。 cansul往往会重连 failed nodes，允许它从好的网络状态下恢复。然而离开的节点永远不会联系。 另外，如果一个agent 正在操作一个server，一个优雅的离开方式是重要的，去避免造成一些超出控制的影响. 1.2.3. services registering services 在前面的步骤里，我们运行了我们的第一个agent，查看了集群的成员，并且访问了这个节点。在本节guide，我们将注册我们第一个service，并且query这个service。 defining a service 一个服务，可以通过，提供一个服务定义文件，或者调用一个合适的HTTP API 一个服务定义，是最常用的方式去注册service，所以，我们用这种方式开启下一步。我们将基于上一步的agent 配置。 首先，创建一个目录用于consul configuration。consul loads 所有的配置文件，in the 配置目录，所以一个通用的形式，在unix系统上是定义这个目录like /etc/consul.d(the .d suffix implies \"this directory contaions a set of configuration files\"). $sudo mkdir /etc/consul.d 接下来，我们写一个服务定义文件，我们假装我们有一个服务named\"web\" 跑在80端口，另外，我们给它一个tag，我们可以用来额外的方式查询这个service. $ echo '{\"service\": {\"name\": \"web\", \"tags\": [\"rails\"], \"port\": 80}}' \\ | sudo tee /etc/consul.d/web.json 现在，重启agent，提供这个配置目录 $ consul agent -dev -config-dir=/etc/consul.d 你可以注意到他的输出，同步的这个web service。这意味着这个agent加载了这个服务配置，从配置文件里，并且成功注册了他在这服务catalog。 如果你想去注册multiple services，你可以创建multiple service配置文件在这配置目录里。 querying services Once the agent is started and the service is synced, we can query the service using either the DNS or HTTP API. DNS API 让我们首先请求我们的服务，用DNS API。for the DNS API, the DNS name for servics is NAME.service.consul. By default, all DNS names are always in the consul namespace, though this is configurable. The service subdomain tells Consul we're querying services, and the NAME is the name of the service. For the web service we registered, these conventions and settings yield a fully-qualified domain name of web.service.consul $ dig &127.0.0.1 -p 8600 web.service.consul 你可以看到，一个记录返回了这IP地址，of 这个节点，on which 这个服务存在的。一个记录可以仅仅包含IP地址。 你可以用这DNS API to retrieve the entrie address/port pair as a SRV record $ dig @127.0.0.1 -p 8600 web.service.consul SRV 这个服务记录，说，这个web service 运行在80端口，并且在节点。。上，并且额外的信息返回了，通过这DNS，with the 一个记录 for the node。 实际上，我们也可以通过DNS API去过滤服务用tags， $ dig @127.0.0.1 -p 8600 rails.web.service.consul HTTP API $ curl http://localhost:8500/v1/catalog/service/web [{\"Node\":\"Armons-MacBook-Air\",\"Address\":\"172.20.20.11\",\"ServiceID\":\"web\", \\ \"ServiceName\":\"web\",\"ServiceTags\":[\"rails\"],\"ServicePort\":80}] The catalog API gives all nodes hosting a given service. As we will see later with health checks you'll typically want to query just for healthy instances where the checks are passing. This is what DNS is doing under the hood. Here's a query to look for only healthy instances: $ curl 'http://localhost:8500/v1/health/service/web?passing' [{\"Node\":\"Armons-MacBook-Air\",\"Address\":\"172.20.20.11\",\"Service\":{ \\ \"ID\":\"web\", \"Service\":\"web\", \"Tags\":[\"rails\"],\"Port\":80}, \"Checks\": ...}] updating services 服务定义可以被更新，通过改变配置文件，和发送 a SIGHUP to the agent. 这可以让你更新services 没有任何停机或不可用。 这HTTP API可以被用来，add，remove，modify services dynamically。 1.2.4. Connect 1.2.5. Consul Cluster 1.2.6. Health Checks 1.2.7. KV Data 1.2.8. Web UI 1.3. todos demo TODO 1.4. 参考资料 1.4.1. GitHub https://github.com/hashicorp/consul 1.4.2. Website https://www.consul.io/ "},"micros/go-micro.html":{"url":"micros/go-micro.html","title":"go-micro","keywords":"","body":"1. go-micro1.1. 概述1.1.1. 特性1.2. todos demo1.2.1. 架构1.2.2. 演示1.3. 参考资料1.3.1. GitHub1.3.2. WebSite1. go-micro 1.1. 概述 Micro是一套微服务构建工具库。对于微服务架构的应用，Micro提供平台层面、高度弹性的工具组件，让服务开发者们可以把复杂的分布式系统以简单的方式构建起来，并且尽可能让开发者使用最少的时间完成基础架构的构建。 1.1.1. 特性 网关 Web Dashboard 服务发现 负载均衡 同步通信 异步通信 消息编码 服务接口-Golang开发框架 组件可插拔 1.2. todos demo 1.2.1. 架构 1.2.2. 演示 TODO 1.3. 参考资料 1.3.1. GitHub https://github.com/micro 1.3.2. WebSite https://micro.mu/ https://micro.mu/docs/cn/index.html "},"micros/spring-cloud.html":{"url":"micros/spring-cloud.html","title":"SpringCloud","keywords":"","body":"1. SpringCloud1.1. 概念1.2. 参考资料1. SpringCloud 1.1. 概念 Spring Cloud最早在功能层面为微服务治理定义了一系列标准特性，例如智能路由，熔断机制，服务注册与发现等，并提供了对应的库和组件来实现这些标准特性。到目前为止，这些库和组件被广泛采用。 Spring Cloud缺点： 既博采众家之长，也导致了一些散乱的局面，即用户需要学习和熟悉各组件的”方言“并加以运维，这在客观上提高了应用门槛 需要在代码级别对诸多组件进行控制，包括Sidecar在内的组件都依赖Java的实现，这和微服务的多语言协作目标是背道而驰的 自身并没有对调度，资源，DevOps等提供相关支持，需要借助其他平台来完成，然而目前的容器编排事实标准是k8s，二者的部分功能存在重合或者冲突，这在一定程度上影响了Spring Cloud的长远发展。 1.2. 参考资料 "},"micros/docker.html":{"url":"micros/docker.html","title":"Docker","keywords":"","body":"1. Docker1.1. 概述1.1.1. Container1.1.2. Docker1.2. 使用1.3. 参考资料1.3.1. GitHub1.3.2. WebSite1.3.3. Books1. Docker 1.1. 概述 1.1.1. Container 1.1.2. Docker 事实上的标准 docker，优势，可以构建一个隔离的，稳定的，安全地，高性能的容器运行环境。 1.2. 使用 docker help 1.3. 参考资料 1.3.1. GitHub https://github.com/docker 1.3.2. WebSite https://www.docker.com/ 1.3.3. Books 《Docker技术入门与实战（第3版）》 "},"micros/compose.html":{"url":"micros/compose.html","title":"Docker Compose","keywords":"","body":"1. Docker Compose1.1. 简介1.2. 使用1.3. todos demo1.3.1. demo1.3.2. 演示1. Docker Compose 1.1. 简介 单机服务编排工具 1.2. 使用 docker-compose help 1.3. todos demo 1.3.1. demo https://github.com/mingz2013/demo-todos-go-micro https://github.com/mingz2013/demo-todos-vue 1.3.2. 演示 展示todos demo的代码架构，项目里面的文档 本地演示用docker-compose实现单机部署 展示todos demo的控制台 http://localhost:8082 展示todos demo的vue前端 http://localhost:8082/todos/#/todos 展示进程scale。 "},"micros/swarm.html":{"url":"micros/swarm.html","title":"Docker Swarm","keywords":"","body":"1. Docker Swarm1.1. Docker Machine1.2. Docker Compose1.3. Docker Swarm1.4. Docker Node1.5. Docker Service1.6. Docker Stack1.7. 集群管理面板1.8. 监控与日志1.9. 基于Docker的PaaS平台1.10. Docker持续集成1.11. 参考资料1.11.1. Books1. Docker Swarm Docker Machine 创建 Docker 主机 Docker Swarm 配置集群节点 Docker Service 部署单个集群服务 Docker Stack 部署多个集群服务，以及 GUI 管理页面 docker-machine、docker swarm、docker node、docker service 和 docker stack 常用命令 1.1. Docker Machine Docker Machine是Docker官方编排项目之一，是一个简化Docker安装的命令行工具，可以帮助用户构建拥有Docker运行环境的虚拟机，并能够远程管理虚拟机及其里面的容器。 1.2. Docker Compose Docker Compose是Docker的一种编排服务，是一个用于在Docker上定义并运行复杂应用的工具，可以让用户在集群中部署分布式应用。通过Compose，用户可以很容易的用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker Compose解决了容器与容器之间如何管理编排的问题，适合开发和测试环境。 1.3. Docker Swarm Swarm是Docker公司在2014年12月初发布的一套较为简单的工具，用来管理Docker集群，它将一群Docker宿主机变成一个单一的，虚拟的主机，使用Swarm操作集群，会使用户感觉就像是在一台主机上进行操作。Swarm使用标准的Docker API接口作为其前端访问入口，换言之，各种形式的Docker Client都可以直接与Swarm通信。 1.4. Docker Node 1.5. Docker Service 1.6. Docker Stack 1.7. 集群管理面板 Shipyard Portainer Panamax Seagull 1.8. 监控与日志 cAdvisor 原生集群监控 Logspout 日志处理 Grafana 数据可视化 1.9. 基于Docker的PaaS平台 Deis 轻量级PaaS平台 Tsuru 可扩展PaaS平台, 基于Swarm Flynn 模块化PaaS平台 openshift 1.10. Docker持续集成 Drone 轻量级CI工具 Travis CI 著名的CI/CD服务商 1.11. 参考资料 1.11.1. Books 《容器云运维实战：Docker与Kubernetes集群》 "},"micros/mesos.html":{"url":"micros/mesos.html","title":"Mesos","keywords":"","body":"1. Mesos1. Mesos Mesos项目是源自UC Berkeley的对集群资源进行抽象和管理的开源项目，类似于操作系统内核，使用它可以很容易的实现分布式应用的自动化调度。 同时，Mesos自身也很好的结合和主持了Docker等相关容器技术，基于Mesos已有的大量应用框架，可以实现用户应用的快速上线。 Twitter 宣布抛弃 Mesos 全面转向 Kubernetes "},"micros/k8s.html":{"url":"micros/k8s.html","title":"Kubernetes","keywords":"","body":"1. kubernetes1.1. 概念1.1.1. Helm1.2. 使用1.3. todos demo1.4. 参考资料1.4.1. GitHub1.4.2. WebSite1.4.3. Books1. kubernetes 1.1. 概念 k8s业已称为容器编排领域事实上的标准 还要考虑集群管理，高可用，安全，持续集成等方方面面的问题。 这些关于容器集群管理的问题，其实就是容器编排的问题，即Kubernetes要解决的问题。 Kubernetes特性 自动装箱 自我修复 水平扩展 服务发现和负载均衡 自动发布和回滚 密钥和配置管理 存储编排 批量处理执行 1.1.1. Helm Kuberneres的安装包管理器，类似于yum，apt-get等 K8s类似于微服务层的操作系统，Helm类似于操作系统上的包管理器。 1.2. 使用 1.3. todos demo TODO 1.4. 参考资料 1.4.1. GitHub https://github.com/kubernetes 1.4.2. WebSite https://kubernetes.io/ https://kubernetes.io/zh/docs/tutorials/ 1.4.3. Books 《每天5分钟玩转Kubernetes》 《Kubernetes进阶实战》 《基于Kubernetes的容器云平台实战》 "},"micros/devops.html":{"url":"micros/devops.html","title":"DevOps","keywords":"","body":"1. DevOps1. DevOps DevOps（Development & Operations）即开发运维一体化，可理解为软件研发的一种过程，方法，文化，运动或实践，主要是通过一条高度自动化的流水线来加强开发，测试，运维和其他部门之间的沟通和协作，加速产品和服务的交付。 "},"micros/openshift-3.html":{"url":"micros/openshift-3.html","title":"OpenShift 3","keywords":"","body":"1. OpenShift 31.1. 概念1.1.1. Red Hat1.1.2. OpenShift1.1.3. 混合云1.2. 演示1.3. todos demo1.4. 参考资料1.4.1. GitHub1.4.2. WebSite1.4.3. Books1. OpenShift 3 1.1. 概念 1.1.1. Red Hat Red Hat就是开源软件商业模式的奠基人，而且是目前世界上最大的开源软件公司。 作为一个开源软件公司，red hat所有产品的企业版的源代码也是完全公开的。 Red Hat是Kubernetes, Istio的主要贡献者之一。 1.1.2. OpenShift OpenShift是一个开源容器云平台，是一个基于主流的容器技术Docker及Kubernetes构建的云平台。 通过OpenShift这个平台，企业可以快速在内部网络中构建出一个多租户的云平台，在这朵云上提供应用开发，测试，部署，运维的各项服务（如图1-2所示）。 OpenShift在一个平台上贯通开发，测试，部署，运维的流程，实现高度的自动化，满足应用持续集成及持续交付和部署的需求；满足企业及组织对容器管理，容器编排的需求。 通过OpenShift的灵活架构，企业可以以OpenShift作为核心，在其上搭建一个企业的DevOps引擎，推动企业的DevOps变革和转型。 容器引擎及容器编排组件是两项关键的技术，但还不能满足生产效率的要求。 OpenShift在Docker和k8s的基础上提供了各种功能，以满足业务应用，研发用户及运维用户在生产效率上的诉求。 应用开发框架及中间件 应用及服务目录 自动化流程及工具。 软件自定义网络 性能监控及日志管理 多用户接口 自动化集群部署及管理 OpenShift集成了原生的Kubernetes作为容器编排组件。OpenShift通过Kubernetes来管理容器集群中的机器节点及容器，为业务应用提供： 容器调度 弹性伸缩 异常自愈 持久化卷 服务发现 配置管理 K8s是一个容器编排工具，虽然提供了很多的功能，但只是一个工具。而OpenShift是一整套企业解决方案。 架构概览 核心组件 构建与部署自动化 CI/CD 企业部署 多环境单集群 多环境多集群 多数据中心 高可用 主控节点的高可用 度量与日志管理 度量采集 日志采集 1.1.3. 混合云 1.2. 演示 演示本地macos的OpenShift单节点集群 演示OpenShift的Web Dashboard 1.3. todos demo TODO 1.4. 参考资料 1.4.1. GitHub https://github.com/openshift 1.4.2. WebSite http://www.openshift.org https://www.okd.io/ 1.4.3. Books 《开源容器云OpenShift 构建基于Kubernetes的企业应用云》 "},"micros/serverless.html":{"url":"micros/serverless.html","title":"Serverless","keywords":"","body":"1. Serverless1.1. 概述1.2. 参考资料1. Serverless 1.1. 概述 Serverless下包含的两个概念： 函数即服务，即Function as a Service，简称FaaS 后端即服务，即Backend as a Service，简称BaaS。 目前，Serverless平台主要分为三大类： 公有云上的功能即服务（Functions as a Service，FaaS）解决方案。 运行在共有和私有数据中心的Serverless框架，如Fission运行在Kubernetes上，Funktion运行在Kubernetes上，IBM OpenWhisk运行在Docker上。 提供agnostic应用接口或/和现有Serverless框架增值服务的包装框架，如Serverless.com支持AWS Lambda，Apex支持AWS Lambda。 Serverless适用场景: 应用负载变化显著的场景 基于事件驱动的算法服务化场景 基于事件驱动的数据分析服务化场景 基于事件驱动的数据服务化场景 低频请求场景 1.2. 参考资料 "},"micros/istio.html":{"url":"micros/istio.html","title":"Istio","keywords":"","body":"1. Istio1.1. 概述1.1.1. Service Mesh1.1.2. Istio1.2. todos demo1.3. 参考资料1.3.1. GitHub1.3.2. WebSite1.3.3. Books1. Istio 1.1. 概述 1.1.1. Service Mesh 要讨论服务网格（Service Mesh），就必须提到微服务（Microservices）。 为了解决微服务架构产生的一些问题，以k8s为代表的容器云系统出现了。这类容器云系统以容器技术为基础，在进程级别为微服务提供了一致的部署，调度，伸缩，监控，日志等功能。 然而，除了进程本身的问题，微服务之间的通信和联系更加复杂，其中的观测，控制和服务质量等都成为微服务方案的短板，因此随着k8s成为事实标准，Service mesh顺势登场。 自Service Mesh技术诞生以来，国内外出现了很多产品，下面选择其中几个重要的产品和事件，大概理理Service Mesh相关产品的发展情况。 Buoyant公司的CEO William，曾经给出对服务网格的定义：服务网格是一个独立的基础设施层，用来处理服务之间的通信。 现代的云原生应用是由各种复杂技术构建的服务组成的，服务网格负责在这些组成部分之间进行可靠的请求传递。 目前典型的服务网格通常提供了一组轻量级的网络代理，这些代理会在应用无感知的情况下，同应用并行部署，运行。 Service Mesh主要功能： 负载均衡 服务发现 熔断 动态路由 安全通信 多语言支持 多协议支持 指标和分布式追踪 重试和最后期限 总结一下，Service Mesh实现了四大关键功能： 实现对基础设施的抽象化 为应用请求提供可靠传递 每个业务节点部署轻量级代理 透明化，应用程序无感知。 Service Mesh类似于更高级的一层网络栈。 k8s就是微服务级别的操作系统。 Helm是k8s的包管理工具，类似于yum，apt-get。 Sidecar 1.1.2. Istio 事实上的标准 2017年5月，Google，IBM和Lyft宣布了Istio的诞生。Istio以Envoy为数据平面，通过Sidecar的方式让Envoy同业务容器一起运行，并劫持其通信，接受控制平面的统一管理，在此基础上为服务之间的通信提供了丰富的连接，控制，观察，安全等特性。 Istio一经发布，便立刻获得Red Hat，F5等大牌厂商的响应，虽然立足不稳，但各个合作方都展示了对社区，行业的强大影响力。于是，Istio很快就超越了Linkerd，成为Service Mesh的代表产品。 这里将Istio的特性总结如下。 连接：对网格内部的服务之间的调用所产生的流量进行智能管理，并以此为基础，为微服务的部署，测试和升级等操作提供有力保障。 安全：为网络内部的服务之间的调用提供认证，加密和鉴权支持，在不侵入代码的情况下，加固现有服务，提高其安全性。 策略：在控制面定制策略，并在服务中实施 观察：对服务之间的调用进行跟踪和测量，获取服务的状态信息。 1.2. todos demo TODO 1.3. 参考资料 1.3.1. GitHub https://github.com/istio 1.3.2. WebSite https://istio.io/ https://istio.io/zh/docs/ 1.3.3. Books 《深入浅出Istio：Service Mesh快速入门与实践》 "},"micros/openshift-4.html":{"url":"micros/openshift-4.html","title":"OpenShift 4","keywords":"","body":"1. OpenShift 41.1. 概述1.2. todos demo1.3. 参考资料1.3.1. GitHub1.3.2. WebSite1.3.3. Books1. OpenShift 4 1.1. 概述 集成了Istio 目前处于测试版本状态。 只提供了Linux上的测试部署方案。 1.2. todos demo TODO 1.3. 参考资料 1.3.1. GitHub 1.3.2. WebSite 1.3.3. Books "},"micros/chaos-engineering.html":{"url":"micros/chaos-engineering.html","title":"Chaos Engineering","keywords":"","body":"1. Chaos Engineering1. Chaos Engineering 混沌工程 "},"network/":{"url":"network/","title":"network","keywords":"","body":" Title Date Modified Category network 2019-05-29 12:00 2019-05-29 12:00 micros "},"network/network.html":{"url":"network/network.html","title":"network","keywords":"","body":"1. 网络编程泛讲2. TCP/IP协议3. 网络编程基础API3.1. socket3.2. 字节序4. 高级API5. 服务器模型6. I/O模型7. 事件处理模式7.1. reactor7.2. proactor8. 并发模式9. IO复用10. 参考资料10.1. 参考书籍禁止转载 一些图文 出自参考书籍中的截图，如有侵权，请联系删除 1. 网络编程泛讲 2. TCP/IP协议 3. 网络编程基础API 3.1. socket 3.2. 字节序 4. 高级API 5. 服务器模型 6. I/O模型 7. 事件处理模式 7.1. reactor 7.2. proactor 8. 并发模式 9. IO复用 select，poll，epoll 10. 参考资料 10.1. 参考书籍 《Linux高性能服务器编程》 《后台开发 核心技术与应用实践》 《Linux多线程服务端编程：使用muduo C++网络库》 "}}