{"./":{"url":"./","title":"Introduction","keywords":"","body":"之前的 blog项目实在不好用，以后的笔记都转移到这里来 流程图插件 https://github.com/knsv/mermaid "},"every_day_use/":{"url":"every_day_use/","title":"every day use","keywords":"","body":"1. every day use Title Date Modified Category every day use 2019-06-06 12:00 2019-06-06 12:00 every day use 1. every day use mongo redis docker k8s golang python nodejs adb git svn ctf wireshark nmap shell macos brew sublime vscode vim markdown jetbrains unity chrome "},"every_day_use/mongo.html":{"url":"every_day_use/mongo.html","title":"mongo","keywords":"","body":"1. mongo1.1. use in macos1.2. use in centos 71.2.1. 使用1.3. client1.4. tools Title Date Modified Category mongo 2019-06-06 12:00 2019-06-06 12:00 every day use 1. mongo 1.1. use in macos brew install mongo brew services start mongodb brew services stop mongodb mongod --config /usr/local/etc/mongod.conf 1.2. use in centos 7 vim /etc/yum.repos.d/mongodb-org-4.0.repo ```repo [mongodb-org-4.0] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc - `yum install mongodb-org` - `systemctl restart mongod.service` ## 开启验证 ### 配置 ```conf // /etc/mongod.conf # Run with/without security (without by default) #auth = true #noauth = true 1.2.1. 使用 use spider db.createUser({user:”spider\",pwd:\"spider2016\",roles:[{role:\"dbOwner\",db:\"spider\"}]}) db.auth(spider, spider2016) 1.3. client mongo show dbs use testDBName show collections db.dropDatabase() // 删除数据库 db.pUser.remove({'role':'admin'}) db.bankUser.drop() db.users.find({'id':1}, {'_id':0, 'name':1}) db.users.find({'_id':ObjectId('5cf65f785568e41dbaf66ee6')}) db.post.update({}, {$rename:{url:'site'}}) // 字段改名 db.collection.ensureIndex({a:1}) // 创建索引 db.collection.find({a:5, b:3,c:{$lt:2},d:{$gt:4}}).sort({c:1}) 1.4. tools mongodump -h dbhost -d dbname -o dbdir mongostore -h dbhost -d dbname --directoryerdb dbdir mongoexport --csv -f company_name,item_category,site -d dbName -c collectionName -q '{\"item_category_num\":102}' -o 102.csv mongoimport --db dbName --collection collectionName --file file.json "},"every_day_use/redis.html":{"url":"every_day_use/redis.html","title":"redis","keywords":"","body":"1. redis1.1. use in macos1.2. client Title Date Modified Category redis 2019-06-06 12:00 2019-06-06 12:00 every day use 1. redis 1.1. use in macos brew install redid brew services start redis redis-server /usr/local/etc/redis.conf 1.2. client redis-cli #连接redis服务器 select 1 # 选择数据库 keys * # 查看指定的key type gamedata # 查看指定key的类型 flushdb # 清空数据库 set event_id 1 set user_id 1 GET key hlen db "},"every_day_use/docker.html":{"url":"every_day_use/docker.html","title":"docker","keywords":"","body":"1. Docker1.1. cmd1.2. docker-compose Title Date Modified Category docker 2019-06-06 12:00 2019-06-06 12:00 every day use 1. Docker https://docs.docker.com/ 1.1. cmd docker help docker search 从镜像源搜索软件 docker pull 从镜像源拉取软件 docker images 显示镜像列表 docker ps 显示容器列表 docker run 运行镜像为容器 docker start 启动容器 docker stop 停止运行中的容器 docker rm 删除容器 docker rmi 删除镜像 docker login mingz2013 password # 这里是用户名，不是邮箱 docker run -d consul # -d 后台执行 docker run -d -i -t centos /bin/bash # -d 后台运行 docker exec -it containerID /bin/bash docker attach docker rm $(docker ps -a -q) # 删除容器 docker rmi -f $(docker images -q) # 删除镜像 --link 链接一个容器，起一个别名，在容器内部可用别名访问 1.2. docker-compose docker-compose 的 --links 参数也一样 docker-compose version docker-compose up docker-compose down docker-compose start docker-compose stop docker-compose restart docker-compose pause docker-compose unpause docker-compose build docker-compose create docker-compose images docker-compose pull docker-compose push docker-compose ps docker-compose logs docker-compose exec docker-compose config # 确认并展示compose file docker-compose events docker-compose kill docker-compose rm docker-compose run docker-compose scale #缩放服务个数 docker-compose scale todos-srv=2 WARNING: The scale command is deprecated. Use the up command with the --scale flag instead. docker-compose up -d --scale todos-api=3 docker-compose up -d --scale todos-srv=2;todos-api=3 "},"every_day_use/k8s.html":{"url":"every_day_use/k8s.html","title":"k8s","keywords":"","body":" Title Date Modified Category k8s 2019-06-06 12:00 2019-06-06 12:00 every day use kubectl run kubectl expose kubectl annotate kubectl autoscale kubectl convert kubectl create kubectl create clusterrole kubectl create clusterrolebinding kubectl create configmap kubectl create deployment kubectl create namespace kubectl create poddisruptionbudget kubectl create quota kubectl create role kubectl create rolebinding kubectl create service kubectl create secret kubectl delete kubectl edit kubectl label kubectl patch kubectl replace kubectl rolling-update kubectl rollout kubectl scale kubectl set "},"every_day_use/golang.html":{"url":"every_day_use/golang.html","title":"golang","keywords":"","body":" Title Date Modified Category golang 2019-06-06 12:00 2019-06-06 12:00 every day use go get github.com/xxx/xxx 安装包 go get -u github.com/xxx/xxx 更新 go doc http.ListenAndServe 查看doc go run xxx.go 直接编译执行go go build xxx.go 编译 go install CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build # 交叉编译 "},"every_day_use/python.html":{"url":"every_day_use/python.html","title":"python","keywords":"","body":" Title Date Modified Category 2019-06-06 12:00 2019-06-06 12:00 every day use "},"every_day_use/nodejs.html":{"url":"every_day_use/nodejs.html","title":"nodejs","keywords":"","body":" Title Date Modified Category nodejs 2019-06-06 12:00 2019-06-06 12:00 every day use node install -g gitbook 安装gitbook全局的 npm install -g gitbook-cli "},"every_day_use/adb.html":{"url":"every_day_use/adb.html","title":"adb","keywords":"","body":" Title Date Modified Category adb 2019-06-06 12:00 2019-06-06 12:00 every day use adb shell adb logcat adb install adb uninstall com.xiuxayo.numbers_blast adb install -r final.apk adb shell am start -n com.xiuxayo.numbers_blast/com.xiuxayo.numbers_blast.MainActivity https://apkpure.com/cn/ good way to download apk from google play app store. 拷贝文件 adb push adb pull "},"every_day_use/git.html":{"url":"every_day_use/git.html","title":"git","keywords":"","body":" Title Date Modified Category idapro 2019-06-06 12:00 2019-06-06 12:00 every day use "},"every_day_use/svn.html":{"url":"every_day_use/svn.html","title":"svn","keywords":"","body":" Title Date Modified Category 2019-06-06 12:00 2019-06-06 12:00 every day use "},"every_day_use/ctf.html":{"url":"every_day_use/ctf.html","title":"ctf","keywords":"","body":"1.1. python Title Date Modified Category ctf 2019-06-06 12:00 2019-06-06 12:00 every day use 1.1. python ord(c) # 参数是长度为1的字符串，简称字符。当参数为统一对象时（unicode object），返回能代表该字符的统一编码，当参数为8比特的字符串时，返回该字节的值。例如ord(‘a’) 返回整形数值97，ord(u’\\u2020’)返回8224. chr(i) # 返回一个字符，字符的asc2码等于参数中的整形数值。如chr(97)返回字符’a’ , 该方法是 ord 的反方法。参数必须是0-255的整形数值，否则会抛出valueError错误。 hex() # str() # "},"every_day_use/wireshark.html":{"url":"every_day_use/wireshark.html","title":"wireshark","keywords":"","body":" Title Date Modified Category wireshark 2019-06-06 12:00 2019-06-06 12:00 every day use ip.src==192.168.1.102 // 过滤源ip ip.src==192.168.1.102 and http // 过滤源ip和http协议 ip.src==192.168.1.100 or ip.dst==192.168.1.100 (ip.src==192.168.1.101 or ip.dst==192.168.1.101 or ip.src==192.168.1.100 or ip.dst==192.168.1.100 or ip.dst==192.168.1.107 or ip.src==192.168.1.107) wireshark抓取的pcapng文件 wireshark打开 File->export objects->http->save all 导出所有http请求到文件夹 过滤文件 读取文件 "},"every_day_use/nmap.html":{"url":"every_day_use/nmap.html","title":"nmap","keywords":"","body":" Title Date Modified Category nmap 2019-06-06 12:00 2019-06-06 12:00 every day use nmap -sS -Pn -A 192.168.20.1/24 80-8000 "},"every_day_use/shell.html":{"url":"every_day_use/shell.html","title":"shell","keywords":"","body":"1. 相关资料2. 帮助2.1. 安装man手册中文3. 文件目录操作3.1. 查找目录3.2. 展示目录3.3. du查看某个文件或目录占用磁盘空间的大小3.4. 分割文本文件，为多个小文件4. 按每个文件1000行来分割除5. 按照每个文件100K来分割6. 文本操作6.1. 查看文本文件 内容6.2. 操作命令6.3. 查询日志6.4. 根据每行的空格分割6.5. 去除重复行6.6. 查找非重复行6.7. 查找重复行6.8. 统计7. 后台执行8. 刻盘9. 压缩解压9.1. 压缩（compress）：9.2. 解压操作:10. tar -zxvf /usr/local/auto_bak/test.tar.gz11. where which12. 日期13. 时间14. 用户与权限14.1. 用户管理14.2. chmod 权限解读14.3. 进程管理14.4. 网络相关15. 网络抓包分析16. 系统信息查看17. 远程连接操作18. 拷贝本地文件(夹)到远程服务器，只需要将后面两个参数反过来就可以19. 两个网络命令20. telnet21. 跟踪系统调用22. purge23. 3个常用基于Linux系统命令行WEB网站浏览工具（w3m/Links/Lynx)24. 特殊问题24.1. jq24.2. sed Title Date Modified Category shell 2019-06-06 12:00 2019-06-06 12:00 every day use 1. 相关资料 http://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html 2. 帮助 man # 手册 man ls ls --help 2.1. 安装man手册中文 yum list | grep man | grep page yum install man-pages yum install man-pages-zh-CNalias cman=‘man -M /usr//share/man/zh_CN'man poll cman poll 3. 文件目录操作 ln -s filename sy_file # 建立软连接 # rm -rf dir # 删除目录 3.1. 查找目录 find . -name “poker” find . -name xz find . -name \"*.[c|h]\" 3.2. 展示目录 ls -l ls -h # 转换kb -> MB 3.3. du查看某个文件或目录占用磁盘空间的大小 du -ah —max-depth=1 du -d 1 -h # mac 这个是我想要的结果a表示显示目录下所有的文件和文件夹（不含子目录）， h表示以人类能看懂的方式， max-depth表示目录的深度。 for i in *; do mv \"$i\" \"$i.txt\"; done # 批量加后缀 for i in qianlima_*; do mv “$i\" \"$i.csv\"; done ls | grep ping | grep log | while read line; do wc -l $line;done; 3.4. 分割文本文件，为多个小文件 split 参数： -b ：后面可接欲分割成的档案大小，可加单位，例如 b, k, m 等； -l ：以行数来进行分割； 4. 按每个文件1000行来分割除 split -l 1000 httperr8007.log http httpaa，httpab，httpac ........ 5. 按照每个文件100K来分割 split -b 100k httperr8007.log http httpaa，httpab，httpac ........ 6. 文本操作 6.1. 查看文本文件 内容 cat more less tail head tail -f server.log # 实时查看日志 6.2. 操作命令 grep awk sed Ack Ag grep -A 10 -B 10 ‘Traceback' log/log.log # 显示 traceback 和 前十行 和 后十行 grep -C 10 ’Traceback’ log/log.log # 等价于上一行， -A 10 -B 10 grep “ERROR” log/2016-05-06.log | awk -F '' '{print $1}' | awk '{print $2}' | grep 'jd' | grep 'list' grep python | wc -l 查看日志条数 grep -r ‘123’ . 查找当前目录下所有文件 包含 123 的 行 6.3. 查询日志 find . -name GT712*06_04 | xargs grep ‘Majiang2.saveRecord ok' | grep '440392' 6.4. 根据每行的空格分割 (cat 3.txt | awk ‘{print $1}' && cat 3.txt | awk '{print $2}' && cat 3.txt | awk '{print $3}' && cat 3.txt | awk '{print $4}' && cat 3.txt | awk '{print $5}' | cat 3.txt | awk '{print $6}' | cat 3.txt | awk '{print $7}') | sort | uniq | wc -l (cat 4.txt | awk '{print $2}' | sort | uniq && cat 4.txt | awk '{print $4}' | sort | uniq && cat 4.txt | awk '{print $6}' | sort | uniq && cat 4.txt | awk '{print $6}' | sort | uniq && cat 4.txt | awk '{print $8}' | sort | uniq && cat 4.txt | awk '{print $10}' | sort | uniq && cat 4.txt | awk '{print $12}' | sort | uniq && cat 4.txt | awk '{print $14}' | sort | uniq && cat 4.txt | awk '{print $16}' | sort | uniq && cat 4.txt | awk '{print $18}' | sort | uniq && cat 4.txt | awk '{print $20}' | sort | uniq) | sort | uniq grep 'comId' json.txt | awk -F '\"' '{print $4}' | sort | uniq -c | wc -l grep “MONGO\" 1.txt | awk -F '' '{print $2}' > 2.txt 6.5. 去除重复行 sort file |uniq6.6. 查找非重复行 sort file |uniq -u6.7. 查找重复行 sort file |uniq -d6.8. 统计 sort file | uniq -c cat 3.txt | sort | uniq 去除重复行 cat 1.txt | sort | uniq | wc -l 统计非重复行数量7. 后台执行 nohup pypy modify.py # 后台执行命令 pypy modify.py & # 后台运行命令 命令后加 & command & ： 后台运行，你关掉终端会停止运行 nohup command & ： 后台运行，你关掉终端也会继续运行 8. 刻盘 刻盘：dd if=./Windows10.iso of=/dev/sdc 9. 压缩解压 /usr/local/test tar -cvf /usr/local/auto_bak/test.tar /usr/local/test 仅打包，不压缩 tar -zcvf /usr/local/auto_bak/test.tar.gz /usr/local/test 打包后，以gzip压缩 在参数f后面的压缩文件名是自己取的，习惯上用tar来做，如果加z参数，则以tar.gz 或tgz来代表gzip压缩过的tar file文件 9.1. 压缩（compress）： tar -zcvf /usr/local/auto_bak/test.tar.gz /usr/local/test9.2. 解压操作: 10. tar -zxvf /usr/local/auto_bak/test.tar.gz tar zxvf demo.tar.gz -C demo-dir # 解压到指定目录，前提是目录事先存在 11. where which which pip # 查看pip路径位置 whereis python which pypy | xargs ls -l -G 12. 日期 date +“%Y-%m-%d %H:%M.%S\" date +”%Y%m%d\" --date='1 days ago' 13. 时间 time可统计命令运行时间 time pypy main.py 14. 用户与权限 那就是sudo su 或者sudo -sH 默认缺省为获取root 用户 14.1. 用户管理 useradd name userdel name cat /etc/passwd chown #更改文件所有者 chown tyhall-difang:tyhall-difang -R . chmod #更改文件权限 drwxr-xr-x 7 zhaojm staff 238 Jun 26 19:30 go/ chmod 777 filename 三个标志位， 所有者，用户组，其他用户 每个标志位三个二进制位 读，写，执行 14.2. chmod 权限解读 二、chmod整个命令的形式的用法如下： sudo chmod -（代表类型）×××（所有者）×××（组用户）×××（其他用户） 三位数的每一位都表示一个用户类型的权限设置。取值是0～7，即二进制的[000]~[111]。 这个三位的二进制数的每一位分别表示读、写、执行权限。 如000表示三项权限均无，而100表示只读。这样，我们就有了下面的对应： 0 [000] 无任何权限 4 [100] 只读权限 6 [110] 读写权限 7 [111] 读写执行权限 要求就是： 1、将当前目录中的所有“子目录”的权限设置为755； 2、将当前目录中的所有“文件”的权限设置为644。 解决方法： chmod 644 -R * chmod 755 find -type d 也可以用： 用find彻底些 find /path -type f -exec chmod 644 {} /; find /path -type d -exec chmod 755 {} /; 1060 chmod 664 -R log37 1061 chmod 775 find log37 -type d 14.3. 进程管理 kill -9 3719 # 杀死3719 PID 进程 ps -ef ps -aux | grep python ps -aux | grep phantomjs | awk '{print $2}' | while read line; do kill -9 $line; done ps -A | grep pypy | awk ‘{print $1}’ | xargs kill -9 14.4. 网络相关 netstat -ntlp -n 显示所有选项 -t 只显示tcp连接 -l 只显示listen -p 将program name 附加到 PID后面 lsof -i:80 查看80端口占用情况 netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' 查看网络负载 15. 网络抓包分析 tcpdump tshark 16. 系统信息查看 dmidecode # 查看系统信息 top 查看cpu利用率 iostat 查看io df -hl 查看磁盘 env # 查看当前环境变量 cat /etc/redhat-release 17. 远程连接操作 ssh root@192.168.2.22 #ssh 登录服务器 scp root@www.baidu.com:/home/root/test.txt ./#拷贝远程服务器文件到本地 scp -r root@www.baidu.com:/home/root/myfloder ./ # 拷贝远程服务器文件夹到本地18. 拷贝本地文件(夹)到远程服务器，只需要将后面两个参数反过来就可以 rsync -aupv root@192.168.1.11:/home/test.log /home # 相比scp稳定，速度快 rsync 用于拷贝数据 19. 两个网络命令 socat ,可用于绑定一个程序到一个端口 nc socat tcp-listen:8888, exec:ipython,pty,stderr # 将一个程序转发到一个端口 socat tcp-listen:8888,fork exec:ipython,pty,stderr # 支持并发 socat tcp-listen:8888,fork exec:bash,pty,stderr 20. telnet 退出 ^] ctrl+] 21. 跟踪系统调用 strace strace ls 22. purge 释放内存空间， 系统会自以为是的缓存一些应用，以为你会再次打开 23. 3个常用基于Linux系统命令行WEB网站浏览工具（w3m/Links/Lynx) 24. 特殊问题 我需要在 服务器上 通过 sudo su - tyhall-difang 切换到tyhall-difang 用户，怎么scp tyhall-difang用户下的文件到本地 1 tyhall-difang用户下，chmod 755 /home/tyhall-difang 改为其他人可读可进 2 tyhall-difang用户下拷贝文件到/tmp/目录下 dig DNS查询 adb install ..apk adb install -r 覆盖安装 adb logcat 看日志 压缩所有文件和目录，单独压缩 ls -l | awk '{print $9}' | awk -F '/' '{print $1}'| while read i; do tar -zcvf $i.tar.gz $i;done; 24.1. jq jq json处理工具,shell工具 https://stedolan.github.io/jq/ https://stedolan.github.io/jq/tutorial/ jq . 24.2. sed "},"every_day_use/macos.html":{"url":"every_day_use/macos.html","title":"macos","keywords":"","body":" Title Date Modified Category macos 2019-06-06 12:00 2019-06-06 12:00 every day use command + k 清空terminal屏幕消息 terminal中的复制粘贴 shift ctrl c shift ctrl v 退出telnet ctrl + ] "},"every_day_use/brew.html":{"url":"every_day_use/brew.html","title":"brew","keywords":"","body":"1. brew Title Date Modified Category brew 2019-06-06 12:00 2019-06-06 12:00 every day use 1. brew brew update brew outdated brew upgrade brew upgrade; brew cleanup brew services brew services list brew services start redis brew services stop mongodb brew install redis "},"every_day_use/sublime.html":{"url":"every_day_use/sublime.html","title":"sublime","keywords":"","body":" Title Date Modified Category sublime 2019-06-06 12:00 2019-06-06 12:00 every day use command + shift + p // 打开命令快捷键 set syntax:json // 设置json格式解析 format:javascript // 以js格式化 "},"every_day_use/vscode.html":{"url":"every_day_use/vscode.html","title":"vscode","keywords":"","body":" Title Date Modified Category vscode 2019-06-06 12:00 2019-06-06 12:00 every day use command + shift + p command + p command + shift + N 打开新窗口 command + N 新建文件 "},"every_day_use/vim.html":{"url":"every_day_use/vim.html","title":"vim","keywords":"","body":" Title Date Modified Category vim 2019-06-06 12:00 2019-06-06 12:00 every day use shell命令 :命令模式 :Sex! \"左右分割窗口，在左侧打开文件浏览器 :Sex “上下分割窗口，在上面打开文件浏览器 :vsplit, :new, :split \"分割窗口 :tab new \"打开新tab :/, :? “向前搜索，向后搜索 :e file “切换文件 :%!xxd ---->切换到十六进制显示 :%!xxd -r ---->切回文本方式显示 快捷键 g + t “切换tab ctrl + w \"切换分割窗口 ctrl + h, j, k, l “左下上右 切换窗口 ctrl + p “自动补全 折叠代码：zc 打开折叠：zo 　　 需要注意的是在1、2两种方法中，^V和^M指的是Ctrl+V和Ctrl+M.你必须要手工进行输入，而不是粘贴。 在vi中处理：首先使用vi打开文件，然后按ESC键，接着输入命令：%s/^V^M//. ：%s/^M$//g 　 1.在Vim中可以直接查看文件编码 :set fileencoding 1.在Vim中直接进行转换文件编码,比如将一个文件转换成utf-8格式 :set fileencoding=utf-8 按两下d，删除一行 "},"every_day_use/markdown.html":{"url":"every_day_use/markdown.html","title":"markdown","keywords":"","body":" Title Date Modified Category markdown 2019-06-06 12:00 2019-06-06 12:00 every day use "},"every_day_use/jetbrains.html":{"url":"every_day_use/jetbrains.html","title":"jetbrains","keywords":"","body":"1. 快捷键2. mark directory as -> sources root Title Date Modified Category jetbrains 2019-06-06 12:00 2019-06-06 12:00 every day use 1. 快捷键 Option+Command+l 格式化代码 command + / 注释 alt + / 提示 shift + command + k git push 2. mark directory as -> sources root inspect code， 分析代码 Diagrams ， UML类图 "},"every_day_use/unity.html":{"url":"every_day_use/unity.html","title":"unity","keywords":"","body":"1. 基本操作2. 基础经验 Title Date Modified Category unity 2019-06-06 12:00 2019-06-06 12:00 every day use 1. 基本操作 command + shit + F 先选中摄像机，将场景所见变成摄像机视角 q w e r t y 快捷键 alt + 滑动 改变视角 ctrl + 滑动 缩放场景 command + d 复制一个对象 按住command拖动，一米一米的拖动 2. 基础经验 空物体设坐标为000，子物体和世界坐标一致，便于操作 "},"every_day_use/chrome.html":{"url":"every_day_use/chrome.html","title":"chrome","keywords":"","body":"1. Console API1.1. 命令行1. Console API 当打开 firebug (也包括 Chrome 等浏览器的自带调试工具)，window 下面会注册一个叫做 console 的对象，它提供多种方法向控制台输出信息，供开发人员调试使用。下面是这些方法的一个简单介绍，适时地运用它们，对于提高开发效率很有帮助。 console.log(object[, object, ...]) 使用频率最高的一条语句：向控制台输出一条消息。支持 C 语言 printf 式的格式化输出。当然，也可以不使用格式化输出来达到同样的目的： var animal='frog', count=10; console.log(\"The %s jumped over %d tall buildings\", animal, count); console.log(\"The\", animal, \"jumped over\", count, \"tall buildings\"); console.debug(object[, object, ...]) 向控制台输出一条信息，它包括一个指向该行代码位置的超链接。 console.info(object[, object, ...]) 向控制台输出一条信息，该信息包含一个表示“信息”的图标，和指向该行代码位置的超链接。 console.warn(object[, object, ...]) 同 info。区别是图标与样式不同。 console.error(object[, object, ...]) 同 info。区别是图标与样式不同。error 实际上和 throw new Error() 产生的效果相同，使用该语句时会向浏览器抛出一个 js 异常。 console.assert(expression[, object, ...]) 断言，测试一条表达式是否为真，不为真时将抛出异常（断言失败）。 console.dir(object) 输出一个对象的全部属性（输出结果类似于 DOM 面板中的样式）。 console.dirxml(node) 输出一个 HTML 或者 XML 元素的结构树，点击结构树上面的节点进入到 HTML 面板。 console.trace() 输出 Javascript 执行时的堆栈追踪。 console.group(object[, object, ...]) 输出消息的同时打开一个嵌套块，用以缩进输出的内容。调用 console.groupEnd() 用以结束这个块的输出。 console.groupCollapsed() 同 console.group(); 区别在于嵌套块默认是收起的。 console.time(name) 计时器，当调用 console.timeEnd(name);并传递相同的 name 为参数时，计时停止，并输出执行两条语句之间代码所消耗的时间（毫秒）。 console.profile([title]) 与 profileEnd() 结合使用，用来做性能测试，与 console 面板上 profile 按钮的功能完全相同。 console.count([title]) 输出该行代码被执行的次数，参数 title 将在输出时作为输出结果的前缀使用。 console.clear() 清空控制台 1.1. 命令行 控制台的输出面板右边，是控制台的输入面板（Chrome 调试工具对应为下方），在这里除了可以运行常规的 javascript 代码，还内置了相当数量的命令行可以辅助我们的调试工作，下面是一些常用命令行的简单介绍。 $(id) 返回一个给定 id 的元素。 $$(selector) 返回给定的 css 选择器匹配到的一组元素。 $x(xpath) 返回给定的 XPath 表达式匹配到的一组元素。 $0 在 HTML 面板中选中的元素。 $1 上一次在 HTML 面板中选中的元素。 $n(index) 访问最近 5 个被选中过的元素，index 的范围： 0 – 4。 dir(object) 同 console.dir(object)。 dirxml(node) 同 console.dirxml(node)。 clear() 同 console.clear()。 inspect(object[, tabName])() 在合适的（或一个指定的） tab 中检视一个对象。 keys(object) 返回一个对象的所有属性的键。 values(object) 返回一个对象的所有属性的值。 debug(fn) 在函数第一行添加一个断点，使用 undebug(fn) 移除断点。 monitor(fn) 开启一个函数的调用日志，使用 unmonitor(fn) 关闭该功能。非常有用的一个命令，但是它似乎并没有很好地工作。 monitorEvents(object[, types]) 开启一个元素的某个事件（或所有事件）被触发时的日志记录。用例如下： monitorEvents($0,['click']) 上面的命令行被执行后，将开启当前在 HTML 面板中被选中元素的 click 事件监控，一旦这个元素的 click 事件被触发，事件对象将会在控制台输出。如果不指定第二个参数，将对所有事件进行记录。 profile([title]) 同 console.profile([title]) $x('//div[@id=\"float_icon\"]/div/img')[0].click() 直接操作元素 类似于selenium操作 "},"algorithm/":{"url":"algorithm/","title":"algorithm","keywords":"","body":" Title Date Modified Category algorithm 2019-06-06 12:00 2019-05-29 12:00 algorithm "},"compiler/":{"url":"compiler/","title":"compiler","keywords":"","body":" Title Date Modified Category compiler 2019-06-06 12:00 2019-05-29 12:00 compiler "},"compiler/compiler.html":{"url":"compiler/compiler.html","title":"编程语言泛讲","keywords":"","body":"1. 编程语言的分类1.1. 解释型与编译型之分1.1.1. 解释型1.1.2. 编译型1.2. 动态类型与静态类型之分1.2.1. 动态1.2.2. 静态1.3. 强类型与弱类型之分1.3.1. 强类型1.3.2. 弱类型2. 编译器前端与编译器后端2.1. 编译器前端(Front End)2.2. 编译器后端(Back End)3. 编程语言的开发方法3.1. 工具生成3.2. 手工构造4. 编程语言的开发过程4.1. 编程语言的设计4.1.1. bnf, ebnf定义文法4.1.2. 地铁图描述文法4.1.3. 少许理论知识4.2. 词法分析4.3. 语法分析4.4. 抽象语法树4.5. 语义分析4.6. 符号管理4.7. 生成中间代码4.8. 生成汇编代码4.9. 二进制格式4.10. 二进制生成，汇编器4.11. 可执行文件生成，链接器4.12. 错误处理4.13. 优化5. CPU架构6. 虚拟机的设计6.1. 字节码文件的解析6.2. 运行时数据区6.2.1. 栈(stack)的设计6.2.2. 堆(heap)的设计6.2.3. 局部变量6.2.4. 全局变量6.3. 汇编指令与机器码的设计6.4. 解释器的设计6.5. GC垃圾回收7. JIT8. 编程语言分类漫谈9. 编程语言开发示例demo10. 参考资料10.1. 书籍 Title Date Modified Category compiler 2019-06-06 12:00 2019-05-29 12:00 compiler 禁止转载 一些图文 出自参考书籍中的截图，如有侵权，请联系删除 1. 编程语言的分类 1.1. 解释型与编译型之分 编程语言可分为解释型和编译型。 1.1.1. 解释型 源代码转换为某种中间状态，如语法树，语法树直接执行 源代码，词法分析，生成token串，语法分析，生成分析树，语法分析树，或语法树，抽象语法树，执行 纯粹的解释型，读一句，解释执行一句，执行到有语法错误的时候才会报错 字节码，解释器运行字节码, 也可称为虚拟机 将抽象语法树转换成字节码，字节码可在虚拟机里执行 也有编译的一个过程 1.1.2. 编译型 编译过程 词法分析, 生成token串，语法分析，生成抽象语法树，生成中间代码，生成各个CPU架构的汇编代码，生成各个平台的二进制， 二进制：真实CPU架构下的二进制，或虚拟机下的二进制（操作码或字节码） 链接过程 链接器，链接成可执行文件 1.2. 动态类型与静态类型之分 1.2.1. 动态 1.2.2. 静态 1.3. 强类型与弱类型之分 1.3.1. 强类型 1.3.2. 弱类型 2. 编译器前端与编译器后端 2.1. 编译器前端(Front End) 从源代码到抽象语法树的过程 2.2. 编译器后端(Back End) 从抽象语法树到二进制的过程 3. 编程语言的开发方法 工具型 手工型 3.1. 工具生成 用一些工具，定义一些文法，通过工具输入文法，自动生成编译器代码。 或者 用正则表达式解析源代码 yacc,lex Javacc 3.2. 手工构造 自顶向下的分析，编写代码 4. 编程语言的开发过程 首先进行编程语言的设计，然后是词法分析，语法分析，语义分析，生成抽象语法树，生成中间代码，生成操作码， 4.1. 编程语言的设计 编程语言的设计，有两种文法表示 4.1.1. bnf, ebnf定义文法 BNF（巴科斯范式，Backus Normal Form） EBNF(扩展巴克斯范式，Extend BNF) 示例： 4.1.2. 地铁图描述文法 4.1.3. 少许理论知识 消除左递归（LL（1）） LL(1) LALR(1) 理解 i++ + ++i 怎么执行的 TODO 4.2. 词法分析 将源代码分割成若干个记号（token）的过程。 首先定义token(记号)，用ebnf文法定义词法 每个token有相应的有限自动机 顺序读取源代码文件每个字符，用token的有限自动机来选择生成不同的token 4.3. 语法分析 即从记号构建分析树（parse tree）的过程。分析树也叫作语法树（syntax tree）或抽象语法树（abstract syntax tree，AST）。 用ebnf定义文法，根据文法写不同的解析代码 4.4. 抽象语法树 终结符与非终结符 可直接编写eval方法，执行每个节点 4.5. 语义分析 检查AST中，是否有语义错误，比如不能除0等 4.6. 符号管理 需要将各个级别的变量，保存到环境变量中，并标记好级别， 在eval的时候，如果生成变量，就new Var，并记录到环境变量中， 如果计算用到了变量，就从环境变量中取出Var用于计算 如果推出当前级别的空间，就释放当前级别的空间内的变量,作用域管理 4.7. 生成中间代码 符号表，语义分析，中间代码优化等。 4.8. 生成汇编代码 了解不同CPU架构的汇编语言，或自定义虚拟机的汇编语法 汇编代码优化 4.9. 二进制格式 4.10. 二进制生成，汇编器 了解各个平台的可执行文件结构，格式，编写汇编器，生成二进制 4.11. 可执行文件生成，链接器 链接成可执行文件 4.12. 错误处理 伴随着每个过程，都需要有错误处理，和友好的错误提示 4.13. 优化 中间代码优化，汇编代码优化，等，每一部分都有优化部分 5. CPU架构 intel x86 ARM Power TODO 6. 虚拟机的设计 模拟真实CPU架构 定义栈空间，定义堆空间，定义寄存器，等数据结构 6.1. 字节码文件的解析 读取文件，读取一个个指令，巨大的switch case结构 6.2. 运行时数据区 6.2.1. 栈(stack)的设计 栈帧 6.2.2. 堆(heap)的设计 6.2.3. 局部变量 6.2.4. 全局变量 6.3. 汇编指令与机器码的设计 6.4. 解释器的设计 6.5. GC垃圾回收 7. JIT java，.NET Framework都具备在运行的同时将字节码转换为机器码的功能，这叫做JIT，Just-In-Time编译技术。 8. 编程语言分类漫谈 JVM虚拟机，Java，Groovy，Scala，Clojure，Jython，JRuby等。 CPython Pypy go js 9. 编程语言开发示例demo py.calc解释型语言 10. 参考资料 10.1. 书籍 《Lua设计与实现》 《Lua 源码欣赏》 《Go 1.5 源码剖析》 《Python源码剖析--深度探索动态语言核心技术》 《编译器构造（Java语言版）》 《自己动手写Java虚拟机》 《揭秘Java虚拟机-JVM设计原理与实现》 《自制编程语言》 《两周自制脚本语言》 《自制编译器》 《自己动手构造编译系统 编译、汇编与链接》 《自己动手写编译器、链接器》 《C编译器剖析》 《可变目标C编译器：设计与实现》 《深入分析GCC》 《高级编译器设计与实现》 《编译系统透视 图解编译原理》 《编译原理》 《现代编译原理：c语言描述》 《程序是怎样跑起来的》 《计算的本质：深入剖析程序和计算机》 "},"compiler/ollvm.html":{"url":"compiler/ollvm.html","title":"ollvm","keywords":"","body":"1. 做的事情2. 名词介绍2.1. gcc2.2. llvm2.3. clang2.4. ollvm3. llvm相关架构与原理4. ollvm扩展内容5. demo6. 攻与防7. github8. 参考书籍9. links Title Date Modified Category compiler 2019-06-06 12:00 2019-05-29 12:00 compiler 1. 做的事情 之前已经做的东西，资源加密，符号混淆 本次做的事情，代码膨胀，变形 2. 名词介绍 2.1. gcc GNU编译器套件（GNU Compiler Collection）包括C、C++、Objective-C、Fortran、Java、Ada和Go语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）。GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由。 2.2. llvm LLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。 2.3. clang Clang是一个C语言、C++、Objective-C语言的轻量级编译器。源代码发布于BSD协议下。Clang将支持其普通lambda表达式、返回类型的简化处理以及更好的处理constexpr关键字。 2.4. ollvm OLLVM（Obfuscator-LLVM）是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个项目，这个项目的目标是提供一个LLVM编译套件的开源分支，能够通过代码混淆和防篡改，增加对逆向工程的难度，提供更高的软件安全性。目前，OLLVM已经支持LLVM-4.0.1版本。OLLVM的混淆操作就是在中间表示IR层，通过编写Pass来混淆IR，然后后端依据IR来生成的目标代码也就被混淆了。得益于LLVM的设计，OLLVM适用LLVM支持的所有语言（C, C++, Objective-C, Ada 和 Fortran）和目标平台（x86, x86-64, PowerPC, PowerPC-64, ARM, Thumb, SPARC, Alpha, CellSPU,MIPS, MSP430, SystemZ, 和 XCore） 3. llvm相关架构与原理 https://llvm.org/docs/ http://www.aosabook.org/en/llvm.html https://llvm.org/docs/WritingAnLLVMPass.html 4. ollvm扩展内容 https://github.com/obfuscator-llvm/obfuscator/wiki -fla 控制流扁平化的PASS参数 -sub指令替换的PASS参数 -bcf虚假控制流的PASS参数 https://blog.csdn.net/chrisnotfound/article/details/79026449 5. demo 用Armariris演示编译一个简单的C源码，试用各种参数。 对编译出的二进制进行分析，查看文件大小，用ida分析二进制，展示流图。 6. 攻与防 https://bbs.pediy.com/thread-217727.htm http://www.freebuf.com/articles/terminal/130142.html 7. github llvm ollvm Hikari Armariris mcsema 8. 参考书籍 《iOS应用逆向与安全》 《编译与反编译技术实战》 《LLVM Cookbook中文版》 9. links gcc clang LLVM和GCC的区别 "},"lang/":{"url":"lang/","title":"lang","keywords":"","body":" Title Date Modified Category lang 2019-06-06 12:00 2019-05-29 12:00 lang "},"lang/golang/":{"url":"lang/golang/","title":"golang","keywords":"","body":" Title Date Modified Category golang 2019-06-06 12:00 2019-05-29 12:00 lang "},"lang/html/":{"url":"lang/html/","title":"html","keywords":"","body":" Title Date Modified Category html 2019-06-06 12:00 2019-05-29 12:00 lang "},"lang/js/":{"url":"lang/js/","title":"js","keywords":"","body":" Title Date Modified Category js 2019-06-06 12:00 2019-05-29 12:00 lang "},"lang/python/":{"url":"lang/python/","title":"python","keywords":"","body":" Title Date Modified Category python 2019-06-06 12:00 2019-05-29 12:00 lang "},"unix-like/":{"url":"unix-like/","title":"Unix-like","keywords":"","body":" Title Date Modified Category linux 2019-06-06 12:00 2019-05-29 12:00 linux "},"micros/":{"url":"micros/","title":"micros","keywords":"","body":"1. MicroService架构探索 Title Date Modified Category micros 2019-05-29 12:00 2019-06-10 12:00 micros 禁止转载 本目录内文章，图片和文字资源大多来自于网络和参考书籍，如有侵权，请联系删除 1. MicroService架构探索 各位领导大家好，今天给大家汇报一下最近的一些关于微服务的研究。 MicroService Consul go-micro SpringCloud Docker Docker Compose Docker Swarm Mesos Kubernetes DevOps OpenShift 3 Serverless Istio OpenShift 4 Rancher Chaos Engineering 总结 Q & A "},"micros/microservice.html":{"url":"micros/microservice.html","title":"MicroService","keywords":"","body":"1. MicroService1.1. 概述1.1.1. 微服务设计的理念：1.1.2. 为什么要使用微服务1.1.3. 微服务特点，如下所述。1.1.4. 微服务带来的问题。1.2. todos demo1.3. 参考资料 Title Date Modified Category micros 2019-05-29 12:00 2019-05-29 12:00 micros 1. MicroService 1.1. 概述 微服务是一种软件架构模式，用来把大而重的应用程序切成许多可管理的、可管理的独立服务，各服务之间的通信并不受不同语言的协议影响，每个服务只管做好一件事情。 1.1.1. 微服务设计的理念： 各服务要小 - 单一的业务目标应该是要细粒度，就像Unix的”只做一件事并且要做好”理念。 组织文化要包含部署与测试的自动化，这个降低管理与操作的负担。 设计原则要包含失败与错误，就像抗脆弱的系统。 1.1.2. 为什么要使用微服务 随着组织的扩大，使用的技术和员工的数量都在增加，管理单一代码实现的服务，只会变得越来越复杂。 1.1.3. 微服务特点，如下所述。 在结构上，将原有的从技术角度拆分的组件，升级为从业务角度拆分的独立运行的服务，这些服务具备各自的实现平台，并且独占自有数据，在服务之间以智能端点和哑管道的方式通信。 在工程上，从产品而非项目的角度进行设计，强调迭代，自动化和面向故障的设计方法。 1.1.4. 微服务带来的问题。 微服务架构在很大程度上提高了应用的伸缩性，方便了部门或业务之间的协作，使技术岗位能够更好地引入新技术并提高自动化程度，最终达到减耗增效的目的，然而和所有新方法一样，微服务架构在解决老问题的同时，也带来了一些新问题，例如： 实例数量急剧增长，对部署和运维的自动化要求更高。 用网络调动代替内部API，对网络这一不可靠的基础设施依赖增强 调用链路变长，分布式跟踪称为必选项目 日志分散严重，跟踪和分析难度加大 服务分散，受攻击面积更大 在不同的服务之间存在协作关系，需要有更好的跨服务控制协调能力 自动伸缩，路由管理，故障控制，存储共享，等等。 1.2. todos demo TODO 1.3. 参考资料 "},"micros/consul.html":{"url":"micros/consul.html","title":"Consul","keywords":"","body":"1. Consul1.1. 概念1.1.1. 服务注册与发现1.1.2. Consul1.2. 演示1.2.1. install consul1.2.2. run the agent1.2.3. services1.2.4. Connect1.2.5. Consul Cluster1.2.6. Health Checks1.2.7. KV Data1.2.8. Web UI1.3. todos demo1.4. 参考资料1.4.1. GitHub1.4.2. Website Title Date Modified Category micros 2019-05-29 12:00 2019-05-29 12:00 micros 1. Consul 1.1. 概念 1.1.1. 服务注册与发现 1.1.2. Consul 1.2. 演示 1.2.1. install consul $brew install consul verifying the installation $consul 1.2.2. run the agent starting the agent $consul agent -dev 为了简单，我们以开发模式启动consul agent。这个模式可以快速和容易的启动一个单节点的consul环境. 这个模式不适合用于生产环境，因为它不保存任何状态。 cluster members $consul members Node Address Status Type Build Protocol DC Segment avril.local 127.0.0.1:8301 alive server 1.3.0 2 dc1 在另一个terminal中执行consul members，你可以看到consul cluster的members，你可以看到，只有 one member（yourself）. 输出显示了我们自己的node，这address it is running on，its health state, its role in the cluster, and some version information. 额外的元数据信息可以通过-detailed flag看到. 这个命令的输出，基于gossip protocol, and is 最终一致的。也就是说，在任何节点在同一时间，看到的世界，by 你本地的agent 可能不完全匹配这状态在servers。一个强一致的系统的展示，可以用这HTTP API 去远程请求consul servers $curl localhost:8500/v1/catalog/nodes [ { \"ID\": \"9a8b671d-ffdb-6445-f436-9ad02cf7d219\", \"Node\": \"avril.local\", \"Address\": \"127.0.0.1\", \"Datacenter\": \"dc1\", \"TaggedAddresses\": { \"lan\": \"127.0.0.1\", \"wan\": \"127.0.0.1\" }, \"Meta\": { \"consul-network-segment\": \"\" }, \"CreateIndex\": 9, \"ModifyIndex\": 10 } ] 对于这个HTTP API额外的说一下，DNS interface可以被用来请求这个节点。提示：你必须确保你的DNS 发现 指向 consul agent's DNS server, which 运行在 8600默认端口上的。这DNS 入口的格式，（类似 \"avril.local.node.consul\"）可以被发现在一会 $dig @127.0.0.1 -p 8600 avril.local.node.cansul ; > DiG 9.10.6 > @127.0.0.1 -p 8600 avril.local.node.cansul ; (1 server found) ;; global options: +cmd ;; Got answer: ;; ->>HEADERstopping the agent 你可以ctrl-C去优雅的停止这个agent，当中断这个agent，你可以看到，它离开的cluster，and shut down。 为了优雅的leaving，consul 通知其他集群成员，这个节点离开了。如果你强行kill这个agent 进程，其他成员将发现这个node fail的。 当一个成员离开，它的服务和检查，将从catalog移除。当一个成员fails，它的健康仅仅标记为critical, 但它不会从catalog中移除。 cansul往往会重连 failed nodes，允许它从好的网络状态下恢复。然而离开的节点永远不会联系。 另外，如果一个agent 正在操作一个server，一个优雅的离开方式是重要的，去避免造成一些超出控制的影响. 1.2.3. services registering services 在前面的步骤里，我们运行了我们的第一个agent，查看了集群的成员，并且访问了这个节点。在本节guide，我们将注册我们第一个service，并且query这个service。 defining a service 一个服务，可以通过，提供一个服务定义文件，或者调用一个合适的HTTP API 一个服务定义，是最常用的方式去注册service，所以，我们用这种方式开启下一步。我们将基于上一步的agent 配置。 首先，创建一个目录用于consul configuration。consul loads 所有的配置文件，in the 配置目录，所以一个通用的形式，在unix系统上是定义这个目录like /etc/consul.d(the .d suffix implies \"this directory contaions a set of configuration files\"). $sudo mkdir /etc/consul.d 接下来，我们写一个服务定义文件，我们假装我们有一个服务named\"web\" 跑在80端口，另外，我们给它一个tag，我们可以用来额外的方式查询这个service. $ echo '{\"service\": {\"name\": \"web\", \"tags\": [\"rails\"], \"port\": 80}}' \\ | sudo tee /etc/consul.d/web.json 现在，重启agent，提供这个配置目录 $ consul agent -dev -config-dir=/etc/consul.d 你可以注意到他的输出，同步的这个web service。这意味着这个agent加载了这个服务配置，从配置文件里，并且成功注册了他在这服务catalog。 如果你想去注册multiple services，你可以创建multiple service配置文件在这配置目录里。 querying services Once the agent is started and the service is synced, we can query the service using either the DNS or HTTP API. DNS API 让我们首先请求我们的服务，用DNS API。for the DNS API, the DNS name for servics is NAME.service.consul. By default, all DNS names are always in the consul namespace, though this is configurable. The service subdomain tells Consul we're querying services, and the NAME is the name of the service. For the web service we registered, these conventions and settings yield a fully-qualified domain name of web.service.consul $ dig @127.0.0.1 -p 8600 web.service.consul 你可以看到，一个记录返回了这IP地址，of 这个节点，on which 这个服务存在的。一个记录可以仅仅包含IP地址。 你可以用这DNS API to retrieve the entrie address/port pair as a SRV record $ dig @127.0.0.1 -p 8600 web.service.consul SRV 这个服务记录，说，这个web service 运行在80端口，并且在节点。。上，并且额外的信息返回了，通过这DNS，with the 一个记录 for the node。 实际上，我们也可以通过DNS API去过滤服务用tags， $ dig @127.0.0.1 -p 8600 rails.web.service.consul HTTP API $ curl http://localhost:8500/v1/catalog/service/web [{\"Node\":\"Armons-MacBook-Air\",\"Address\":\"172.20.20.11\",\"ServiceID\":\"web\", \\ \"ServiceName\":\"web\",\"ServiceTags\":[\"rails\"],\"ServicePort\":80}] The catalog API gives all nodes hosting a given service. As we will see later with health checks you'll typically want to query just for healthy instances where the checks are passing. This is what DNS is doing under the hood. Here's a query to look for only healthy instances: $ curl 'http://localhost:8500/v1/health/service/web?passing' [{\"Node\":\"Armons-MacBook-Air\",\"Address\":\"172.20.20.11\",\"Service\":{ \\ \"ID\":\"web\", \"Service\":\"web\", \"Tags\":[\"rails\"],\"Port\":80}, \"Checks\": ...}] updating services 服务定义可以被更新，通过改变配置文件，和发送 a SIGHUP to the agent. 这可以让你更新services 没有任何停机或不可用。 这HTTP API可以被用来，add，remove，modify services dynamically。 1.2.4. Connect 1.2.5. Consul Cluster 1.2.6. Health Checks 1.2.7. KV Data 1.2.8. Web UI 1.3. todos demo TODO 1.4. 参考资料 1.4.1. GitHub https://github.com/hashicorp/consul 1.4.2. Website https://www.consul.io/ "},"micros/go-micro.html":{"url":"micros/go-micro.html","title":"go-micro","keywords":"","body":"1. go-micro1.1. 概述1.1.1. 特性1.2. todos demo1.2.1. 架构1.2.2. 演示1.3. 参考资料1.3.1. GitHub1.3.2. WebSite Title Date Modified Category micros 2019-05-29 12:00 2019-05-29 12:00 micros 1. go-micro 1.1. 概述 Micro是一套微服务构建工具库。对于微服务架构的应用，Micro提供平台层面、高度弹性的工具组件，让服务开发者们可以把复杂的分布式系统以简单的方式构建起来，并且尽可能让开发者使用最少的时间完成基础架构的构建。 1.1.1. 特性 网关 Web Dashboard 服务发现 负载均衡 同步通信 异步通信 消息编码 服务接口-Golang开发框架 组件可插拔 1.2. todos demo 1.2.1. 架构 1.2.2. 演示 TODO 1.3. 参考资料 1.3.1. GitHub https://github.com/micro 1.3.2. WebSite https://micro.mu/ https://micro.mu/docs/cn/index.html "},"micros/spring-cloud.html":{"url":"micros/spring-cloud.html","title":"SpringCloud","keywords":"","body":"1. SpringCloud1.1. 概念1.2. 参考资料 Title Date Modified Category micros 2019-05-29 12:00 2019-05-29 12:00 micros 1. SpringCloud 1.1. 概念 Spring Cloud最早在功能层面为微服务治理定义了一系列标准特性，例如智能路由，熔断机制，服务注册与发现等，并提供了对应的库和组件来实现这些标准特性。到目前为止，这些库和组件被广泛采用。 Spring Cloud缺点： 既博采众家之长，也导致了一些散乱的局面，即用户需要学习和熟悉各组件的”方言“并加以运维，这在客观上提高了应用门槛 需要在代码级别对诸多组件进行控制，包括Sidecar在内的组件都依赖Java的实现，这和微服务的多语言协作目标是背道而驰的 自身并没有对调度，资源，DevOps等提供相关支持，需要借助其他平台来完成，然而目前的容器编排事实标准是k8s，二者的部分功能存在重合或者冲突，这在一定程度上影响了Spring Cloud的长远发展。 1.2. 参考资料 "},"micros/docker.html":{"url":"micros/docker.html","title":"Docker","keywords":"","body":"1. Docker1.1. 概述1.1.1. Container1.1.2. Docker1.2. 使用1.3. Docker 与微服务1.4. 参考资料1.4.1. GitHub1.4.2. WebSite1.4.3. Books Title Date Modified Category micros 2019-05-29 12:00 2019-05-29 12:00 micros 1. Docker 1.1. 概述 1.1.1. Container 1.1.2. Docker 事实上的标准 docker，优势，可以构建一个隔离的，稳定的，安全地，高性能的容器运行环境。 1.2. 使用 docker help 1.3. Docker 与微服务 1.4. 参考资料 1.4.1. GitHub https://github.com/docker 1.4.2. WebSite https://www.docker.com/ 1.4.3. Books 《Docker技术入门与实战（第3版）》 "},"micros/docker-compose.html":{"url":"micros/docker-compose.html","title":"Docker Compose","keywords":"","body":"1. Docker Compose1.1. 简介1.2. 使用1.3. todos demo1.3.1. demo1.3.2. 演示 Title Date Modified Category micros 2019-05-29 12:00 2019-05-29 12:00 micros 1. Docker Compose 1.1. 简介 单机服务编排工具 1.2. 使用 docker-compose help 1.3. todos demo 1.3.1. demo https://github.com/mingz2013/demo-todos-go-micro https://github.com/mingz2013/demo-todos-vue 1.3.2. 演示 展示todos demo的代码架构，项目里面的文档 本地演示用docker-compose实现单机部署 展示todos demo的控制台 http://localhost:8082 展示todos demo的vue前端 http://localhost:8082/todos/#/todos 展示进程scale。 "},"micros/docker-swarm.html":{"url":"micros/docker-swarm.html","title":"Docker Swarm","keywords":"","body":"1. Docker Swarm1.1. Docker Machine1.2. Docker Compose1.3. Docker Swarm1.4. Docker Node1.5. Docker Service1.6. Docker Stack1.7. Docker Network1.8. 集群管理面板1.9. 监控与日志1.10. 基于Docker的PaaS平台1.11. Docker持续集成1.12. 私有镜像仓库1.13. todos demo1.13.1. 演示1.14. 参考资料1.14.1. Books Title Date Modified Category micros 2019-05-29 12:00 2019-05-29 12:00 micros 1. Docker Swarm Docker Machine 创建 Docker 主机 Docker Swarm 配置集群节点 Docker Service 部署单个集群服务 Docker Stack 部署多个服务，以及 GUI 管理页面 docker-machine、docker swarm、docker node、docker service 和 docker stack 常用命令 1.1. Docker Machine Docker Machine是Docker官方编排项目之一，是一个简化Docker安装的命令行工具，可以帮助用户构建拥有Docker运行环境的虚拟机，并能够远程管理虚拟机及其里面的容器。 1.2. Docker Compose Docker Compose是Docker的一种编排服务，是一个用于在Docker上定义并运行复杂应用的工具，可以让用户在集群中部署分布式应用。通过Compose，用户可以很容易的用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker Compose解决了容器与容器之间如何管理编排的问题，适合开发和测试环境。 1.3. Docker Swarm Swarm是Docker公司在2014年12月初发布的一套较为简单的工具，用来管理Docker集群，它将一群Docker宿主机变成一个单一的，虚拟的主机，使用Swarm操作集群，会使用户感觉就像是在一台主机上进行操作。Swarm使用标准的Docker API接口作为其前端访问入口，换言之，各种形式的Docker Client都可以直接与Swarm通信。 1.4. Docker Node 1.5. Docker Service 1.6. Docker Stack stack 是构成特定环境中的 service 集合, 它是自动部署多个相互关联的服务的简便方法，而无需单独定义每个服务。 docker stack忽略构建命令，无法使用stack构建新镜像。 stack 是一组相互关联的服务，它是服务的上一层，这些服务共享依赖关系，并且可以一起编排和缩放。 单个 stack 能够定义和协调整个应用程序的功能，简单来说 stack 就是一组服务的集合。 1.7. Docker Network 1.8. 集群管理面板 Shipyard Portainer ** Panamax Seagull 1.9. 监控与日志 cAdvisor 原生集群监控 Logspout 日志处理 Grafana 数据可视化 1.10. 基于Docker的PaaS平台 Deis 轻量级PaaS平台 Tsuru 可扩展PaaS平台, 基于Swarm Flynn 模块化PaaS平台 openshift 1.11. Docker持续集成 Drone 轻量级CI工具 Travis CI 著名的CI/CD服务商 1.12. 私有镜像仓库 https://github.com/docker/distribution VMWare Harbor SUSE Portus 1.13. todos demo https://github.com/mingz2013/demo-todos-go-micro 1.13.1. 演示 搭建单节点swarm集群 用栈部署todos demo 部署Portainer 用Portainer管理页面管理todos demo。 1.14. 参考资料 1.14.1. Books 《容器云运维实战：Docker与Kubernetes集群》 "},"micros/mesos.html":{"url":"micros/mesos.html","title":"Mesos","keywords":"","body":"1. Mesos Title Date Modified Category micros 2019-05-29 12:00 2019-05-29 12:00 micros 1. Mesos Mesos项目是源自UC Berkeley的对集群资源进行抽象和管理的开源项目，类似于操作系统内核，使用它可以很容易的实现分布式应用的自动化调度。 同时，Mesos自身也很好的结合和主持了Docker等相关容器技术，基于Mesos已有的大量应用框架，可以实现用户应用的快速上线。 Twitter 宣布抛弃 Mesos 全面转向 Kubernetes "},"micros/k8s.html":{"url":"micros/k8s.html","title":"Kubernetes","keywords":"","body":"1. kubernetes1.1. 概念1.1.1. Helm1.2. 使用1.3. dashboard1.4. todos demo1.5. 参考资料1.5.1. GitHub1.5.2. WebSite1.5.3. Books Title Date Modified Category micros 2019-05-29 12:00 2019-05-29 12:00 micros 1. kubernetes 1.1. 概念 k8s业已称为容器编排领域事实上的标准 还要考虑集群管理，高可用，安全，持续集成等方方面面的问题。 这些关于容器集群管理的问题，其实就是容器编排的问题，即Kubernetes要解决的问题。 Kubernetes特性 自动装箱 自我修复 水平扩展 服务发现和负载均衡 自动发布和回滚 密钥和配置管理 存储编排 批量处理执行 1.1.1. Helm Kuberneres的安装包管理器，类似于yum，apt-get等 K8s类似于微服务层的操作系统，Helm类似于操作系统上的包管理器。 1.2. 使用 1.3. dashboard 1.4. todos demo TODO 1.5. 参考资料 1.5.1. GitHub https://github.com/kubernetes 1.5.2. WebSite https://kubernetes.io/ https://kubernetes.io/zh/docs/tutorials/ 1.5.3. Books 《每天5分钟玩转Kubernetes》 《Kubernetes进阶实战》 《基于Kubernetes的容器云平台实战》 "},"micros/devops.html":{"url":"micros/devops.html","title":"DevOps","keywords":"","body":"1. DevOps Title Date Modified Category micros 2019-05-29 12:00 2019-05-29 12:00 micros 1. DevOps DevOps（Development & Operations）即开发运维一体化，可理解为软件研发的一种过程，方法，文化，运动或实践，主要是通过一条高度自动化的流水线来加强开发，测试，运维和其他部门之间的沟通和协作，加速产品和服务的交付。 "},"micros/openshift-3.html":{"url":"micros/openshift-3.html","title":"OpenShift 3","keywords":"","body":"1. OpenShift 31.1. 概念1.1.1. Red Hat1.1.2. OpenShift1.1.3. 混合云1.2. 演示1.3. todos demo1.4. 参考资料1.4.1. GitHub1.4.2. WebSite1.4.3. Books Title Date Modified Category micros 2019-05-29 12:00 2019-05-29 12:00 micros 1. OpenShift 3 1.1. 概念 1.1.1. Red Hat Red Hat就是开源软件商业模式的奠基人，而且是目前世界上最大的开源软件公司。 作为一个开源软件公司，red hat所有产品的企业版的源代码也是完全公开的。 Red Hat是Kubernetes, Istio的主要贡献者之一。 1.1.2. OpenShift OpenShift是一个开源容器云平台，是一个基于主流的容器技术Docker及Kubernetes构建的云平台。 通过OpenShift这个平台，企业可以快速在内部网络中构建出一个多租户的云平台，在这朵云上提供应用开发，测试，部署，运维的各项服务（如图1-2所示）。 OpenShift在一个平台上贯通开发，测试，部署，运维的流程，实现高度的自动化，满足应用持续集成及持续交付和部署的需求；满足企业及组织对容器管理，容器编排的需求。 通过OpenShift的灵活架构，企业可以以OpenShift作为核心，在其上搭建一个企业的DevOps引擎，推动企业的DevOps变革和转型。 容器引擎及容器编排组件是两项关键的技术，但还不能满足生产效率的要求。 OpenShift在Docker和k8s的基础上提供了各种功能，以满足业务应用，研发用户及运维用户在生产效率上的诉求。 应用开发框架及中间件 应用及服务目录 自动化流程及工具。 软件自定义网络 性能监控及日志管理 多用户接口 自动化集群部署及管理 OpenShift集成了原生的Kubernetes作为容器编排组件。OpenShift通过Kubernetes来管理容器集群中的机器节点及容器，为业务应用提供： 容器调度 弹性伸缩 异常自愈 持久化卷 服务发现 配置管理 K8s是一个容器编排工具，虽然提供了很多的功能，但只是一个工具。而OpenShift是一整套企业解决方案。 架构概览 核心组件 构建与部署自动化 CI/CD 企业部署 多环境单集群 多环境多集群 多数据中心 高可用 主控节点的高可用 度量与日志管理 度量采集 日志采集 1.1.3. 混合云 1.2. 演示 演示本地macos的OpenShift单节点集群 演示OpenShift的Web Dashboard 1.3. todos demo TODO 1.4. 参考资料 1.4.1. GitHub https://github.com/openshift 1.4.2. WebSite http://www.openshift.org https://www.okd.io/ 1.4.3. Books 《开源容器云OpenShift 构建基于Kubernetes的企业应用云》 "},"micros/serverless.html":{"url":"micros/serverless.html","title":"Serverless","keywords":"","body":"1. Serverless1.1. 概述1.2. 参考资料 Title Date Modified Category micros 2019-05-29 12:00 2019-05-29 12:00 micros 1. Serverless 1.1. 概述 Serverless下包含的两个概念： 函数即服务，即Function as a Service，简称FaaS 后端即服务，即Backend as a Service，简称BaaS。 目前，Serverless平台主要分为三大类： 公有云上的功能即服务（Functions as a Service，FaaS）解决方案。 运行在共有和私有数据中心的Serverless框架，如Fission运行在Kubernetes上，Funktion运行在Kubernetes上，IBM OpenWhisk运行在Docker上。 提供agnostic应用接口或/和现有Serverless框架增值服务的包装框架，如Serverless.com支持AWS Lambda，Apex支持AWS Lambda。 Serverless适用场景: 应用负载变化显著的场景 基于事件驱动的算法服务化场景 基于事件驱动的数据分析服务化场景 基于事件驱动的数据服务化场景 低频请求场景 1.2. 参考资料 "},"micros/istio.html":{"url":"micros/istio.html","title":"Istio","keywords":"","body":"1. Istio1.1. 概述1.1.1. Service Mesh1.1.2. Istio1.2. todos demo1.3. 参考资料1.3.1. GitHub1.3.2. WebSite1.3.3. Books Title Date Modified Category micros 2019-05-29 12:00 2019-05-29 12:00 micros 1. Istio 1.1. 概述 1.1.1. Service Mesh 要讨论服务网格（Service Mesh），就必须提到微服务（Microservices）。 为了解决微服务架构产生的一些问题，以k8s为代表的容器云系统出现了。这类容器云系统以容器技术为基础，在进程级别为微服务提供了一致的部署，调度，伸缩，监控，日志等功能。 然而，除了进程本身的问题，微服务之间的通信和联系更加复杂，其中的观测，控制和服务质量等都成为微服务方案的短板，因此随着k8s成为事实标准，Service mesh顺势登场。 自Service Mesh技术诞生以来，国内外出现了很多产品，下面选择其中几个重要的产品和事件，大概理理Service Mesh相关产品的发展情况。 Buoyant公司的CEO William，曾经给出对服务网格的定义：服务网格是一个独立的基础设施层，用来处理服务之间的通信。 现代的云原生应用是由各种复杂技术构建的服务组成的，服务网格负责在这些组成部分之间进行可靠的请求传递。 目前典型的服务网格通常提供了一组轻量级的网络代理，这些代理会在应用无感知的情况下，同应用并行部署，运行。 Service Mesh主要功能： 负载均衡 服务发现 熔断 动态路由 安全通信 多语言支持 多协议支持 指标和分布式追踪 重试和最后期限 总结一下，Service Mesh实现了四大关键功能： 实现对基础设施的抽象化 为应用请求提供可靠传递 每个业务节点部署轻量级代理 透明化，应用程序无感知。 Service Mesh类似于更高级的一层网络栈。 k8s就是微服务级别的操作系统。 Helm是k8s的包管理工具，类似于yum，apt-get。 Sidecar 1.1.2. Istio 事实上的标准 2017年5月，Google，IBM和Lyft宣布了Istio的诞生。Istio以Envoy为数据平面，通过Sidecar的方式让Envoy同业务容器一起运行，并劫持其通信，接受控制平面的统一管理，在此基础上为服务之间的通信提供了丰富的连接，控制，观察，安全等特性。 Istio一经发布，便立刻获得Red Hat，F5等大牌厂商的响应，虽然立足不稳，但各个合作方都展示了对社区，行业的强大影响力。于是，Istio很快就超越了Linkerd，成为Service Mesh的代表产品。 这里将Istio的特性总结如下。 连接：对网格内部的服务之间的调用所产生的流量进行智能管理，并以此为基础，为微服务的部署，测试和升级等操作提供有力保障。 安全：为网络内部的服务之间的调用提供认证，加密和鉴权支持，在不侵入代码的情况下，加固现有服务，提高其安全性。 策略：在控制面定制策略，并在服务中实施 观察：对服务之间的调用进行跟踪和测量，获取服务的状态信息。 1.2. todos demo TODO 1.3. 参考资料 1.3.1. GitHub https://github.com/istio 1.3.2. WebSite https://istio.io/ https://istio.io/zh/docs/ 1.3.3. Books 《深入浅出Istio：Service Mesh快速入门与实践》 "},"micros/openshift-4.html":{"url":"micros/openshift-4.html","title":"OpenShift 4","keywords":"","body":"1. OpenShift 41.1. 概述1.2. todos demo1.3. 参考资料1.3.1. GitHub1.3.2. WebSite1.3.3. Books Title Date Modified Category micros 2019-05-29 12:00 2019-05-29 12:00 micros 1. OpenShift 4 1.1. 概述 集成了Istio 目前处于测试版本状态。 只提供了Linux上的测试部署方案。 1.2. todos demo TODO 1.3. 参考资料 1.3.1. GitHub 1.3.2. WebSite 1.3.3. Books "},"micros/chaos-engineering.html":{"url":"micros/chaos-engineering.html","title":"Chaos Engineering","keywords":"","body":"1. Chaos Engineering Title Date Modified Category micros 2019-05-29 12:00 2019-05-29 12:00 micros 1. Chaos Engineering 混沌工程 "},"network/":{"url":"network/","title":"network","keywords":"","body":" Title Date Modified Category network 2019-05-29 12:00 2019-05-29 12:00 network "},"network/network.html":{"url":"network/network.html","title":"network","keywords":"","body":"1. 网络编程泛讲2. TCP/IP协议3. 网络编程基础API3.1. socket3.2. 字节序4. 高级API5. 服务器模型6. I/O模型7. 事件处理模式7.1. reactor7.2. proactor8. 并发模式9. IO复用10. 参考资料10.1. 参考书籍 Title Date Modified Category network 2019-05-29 12:00 2019-05-29 12:00 network 禁止转载 一些图文 出自参考书籍中的截图，如有侵权，请联系删除 1. 网络编程泛讲 2. TCP/IP协议 3. 网络编程基础API 3.1. socket 3.2. 字节序 4. 高级API 5. 服务器模型 6. I/O模型 7. 事件处理模式 7.1. reactor 7.2. proactor 8. 并发模式 9. IO复用 select，poll，epoll 10. 参考资料 10.1. 参考书籍 《Linux高性能服务器编程》 《后台开发 核心技术与应用实践》 《Linux多线程服务端编程：使用muduo C++网络库》 "},"db/":{"url":"db/","title":"db","keywords":"","body":" Title Date Modified Category db 2019-05-29 12:00 2019-05-29 12:00 db "}}